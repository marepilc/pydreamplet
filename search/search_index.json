{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#the-world-of-creative-visualizations","title":"The world of creative visualizations","text":"<p>Welcome to pyDreamplet \u2013 a gateway to creating stunning SVG visualizations with Python. Whether crafting charts, generating artistic SVG imagery, or exploring innovative ways to manipulate vector graphics, pyDreamplet is designed to bring creative visions to life. This library offers an intuitive yet powerful toolkit for developers and digital artists alike, making it effortless to transform code into captivating visual art.</p> <p>Check out the examples below. Ready to dive in? Explore the Getting Started section to discover a guide that will help you create your first visual. For more inspiration and advanced examples, check out the reference materials and blog, which showcase creative projects and real-world applications of pyDreamplet. Unleash your creativity and start building beautiful visualizations today!</p> Data Vizualization Example - Supplier Quality Performance Data Vizualization Example - World Map Creative coding example"},{"location":"blog/","title":"Data Visualization and Creative Coding Blog","text":"<p>Welcome to the pyDreamplet blog, a space where creativity meets data. Here, we explore the fascinating intersection of art and analytics, transforming raw numbers into compelling visual narratives. Whether you're passionate about data, design, or coding, you'll find inspiration in our diverse range of projects and tutorials.</p> <p>In today's digital world, data is everywhere, yet it often remains hidden behind spreadsheets and statistics. Let's unlock the beauty of data by showcasing innovative visualization techniques and creative coding experiments. From classic charts to avant-garde visual representations, we strive to make data accessible and engaging for everyone.</p>"},{"location":"blog/2025/02/25/line-chart/","title":"Line Chart","text":""},{"location":"blog/2025/02/25/line-chart/#introduction","title":"Introduction","text":"<p>In this tutorial, we will build a line chart that visualizes random (yet smoothly varying) numeric data for multiple products over a set of dates. We will use:</p> <ul> <li>Polars to store and manipulate our data,</li> <li>pyDreamplet to generate an SVG chart,</li> <li>pendulum for dates handling.</li> </ul> <p>Ensure that you have these libraries available. By the end, you\u2019ll have a clear example of how to create a multi-line chart with labels, axes, and grid lines.</p> <p>Now, import everything we need:</p> <pre><code>import pendulum\nimport polars as pl\nimport pydreamplet as dp\n\nfrom pydreamplet.scales import LinearScale, PointScale\nfrom pydreamplet.noise import Noise\nfrom pydreamplet.typography import TypographyMeasurer\nfrom pydreamplet.colors import generate_colors\nfrom pydreamplet.utils import force_distance, sample_uniform, calculate_ticks\nfrom pydreamplet.markers import Marker, TICK_BOTTOM, TICK_LEFT\n</code></pre>"},{"location":"blog/2025/02/25/line-chart/#generating-fake-data","title":"Generating Fake Data","text":"<p>We will create a Polars <code>DataFrame</code> containing daily sales data for 6 products across 100 days. To ensure our random data has a smooth, realistic progression, we\u2019ll use <code>Noise</code> from pyDreamplet.</p> <pre><code># Define product names\nproducts = [\"bicycle\", \"apple\", \"ham\", \"spoon\", \"boat\", \"starship\"]\n\n# Generate synthetic data using pydreamplet's Noise\ndata = []\nfor product in products:\n    noise = Noise(0, 250, 0.1)\n    daily_sales = [noise.int_value for _ in range(100)]\n    data.append(daily_sales)\n\n# Create a Polars DataFrame\ndf = pl.DataFrame(data, schema=products)\n\n# Add a date column (starting from 1 July 2024)\nstart_date = pendulum.date(2024, 7, 1)\nend_date = start_date.add(days=df.height - 1)  # 100 days\ndf = df.with_columns(\n    date=pl.date_range(start_date, end_date, interval=\"1d\")\n).select([\"date\"] + products)\n</code></pre> <p>At this point, <code>df</code> looks something like this (showing the first few rows):</p> date bicycle apple ham spoon boat starship 2024-07-01 00:00:00 85 52 197 15 33 96 2024-07-02 00:00:00 90 47 185 17 41 108 2024-07-03 00:00:00 81 36 173 14 52 108 ... ... ... ... ... ... ..."},{"location":"blog/2025/02/25/line-chart/#determining-chart-bounds-and-layout","title":"Determining Chart Bounds and Layout","text":"<p>We\u2019ll need to figure out the minimum and maximum values to properly scale our chart. We also measure label text widths so that we can position them neatly later.</p> <pre><code># Determine min and max across all products\nmin_value = df.select(products).min_horizontal().min()\nmax_value = df.select(products).max_horizontal().max()\n\n# Measure text width to handle right margin for product labels\nmeasurer = TypographyMeasurer()\nmax_label_width = 0\nfor product in products:\n    label_dimensions = measurer.measure_text(\n        product, font_family=\"Roboto\", weight=400, font_size=16\n    )\n    max_label_width = max(max_label_width, label_dimensions[0])\n\nprint(\"Data range:\", min_value, \"to\", max_value)\nprint(\"Max label width:\", max_label_width)\n</code></pre>"},{"location":"blog/2025/02/25/line-chart/#setting-up-the-svg-canvas-and-scales","title":"Setting Up the SVG Canvas and Scales","text":"<p>Create an SVG with pydreamplet and define our margins. We\u2019ll use:</p> <ul> <li>A <code>PointScale</code> for the X-axis (mapping discrete dates to positions),</li> <li>A <code>LinearScale</code> for the Y-axis (mapping numeric values to vertical positions).</li> </ul> <pre><code># Create an SVG element\nsvg = dp.SVG(800, 400)\n\n# Create a &lt;defs&gt; container for markers\ndefs = dp.SvgElement(\"defs\")\nlayer0 = dp.G()\n\n# Append them to the SVG\nsvg.append(defs, layer0)\n\n# Margins\nmargin = dict(l=50, r=15 + max_label_width, t=15, b=50)\n\n# Extract the dates as a Python list\ndates = df[\"date\"].to_list()\n\n# Define scales\nscale_x = PointScale(dates, (margin[\"l\"], svg.w - margin[\"r\"]))\nscale_y = LinearScale(\n    (min_value, max_value),\n    (svg.h - margin[\"b\"], margin[\"t\"])\n)\n</code></pre>"},{"location":"blog/2025/02/25/line-chart/#plotting-the-lines","title":"Plotting the Lines","text":"<p>For each product, we\u2019ll map each value to the X/Y coordinates and create a <code>Polyline</code>. We\u2019ll also assign a different color to each line using <code>generate_colors</code>.</p> <pre><code># Prepare X positions for each date\nx_values = [scale_x.map(date) for date in dates]\n\n# Generate distinct colors\ncolors = generate_colors(\"#cc340c\", len(products))\n\nlast_points_y = []\nfor i, product in enumerate(products):\n    # Collect (x, y) for each data point\n    points = []\n    for j, value in enumerate(df[product].to_list()):\n        points.extend([x_values[j], scale_y.map(value)])\n\n    # Create the polyline for this product\n    data_line = dp.Polyline(points, stroke=colors[i], fill=\"none\")\n    svg.append(data_line)\n\n    # Store the last y-position for label placement\n    last_points_y.append(points[-1])\n</code></pre> <p></p>"},{"location":"blog/2025/02/25/line-chart/#adding-labels-to-the-lines","title":"Adding Labels to the Lines","text":"<p>We want to place the product name at the end of each line. Since lines might overlap near the end, we use <code>force_distance</code> to spread them out vertically.</p> <pre><code># Spread out the label positions so they don't collide\nlabel_y_positions = force_distance(last_points_y, 16)\n\nfor i, product in enumerate(products):\n    label = dp.Text(\n        product,\n        x=x_values[-1] + 5,\n        y=label_y_positions[i] + 4,\n        font_family=\"Roboto\",\n        font_size=16,\n        fill=colors[i],\n        anchor=\"start\",\n    )\n    svg.append(label)\n</code></pre> <p></p>"},{"location":"blog/2025/02/25/line-chart/#creating-the-x-axis","title":"Creating the X-Axis","text":"<p>We will draw the X-axis at the bottom of the chart and place a few ticks along the date range. We\u2019ll sample 5 dates evenly using <code>sample_uniform</code> and then add text for each tick.</p> <pre><code># Sample 5 dates across the entire range\nx_values_indices = sample_uniform(scale_x.domain, 5, None)\n\n# Draw a base line for the X-axis\nlayer0.append(\n    dp.Line(\n        x1=margin[\"l\"],\n        y1=scale_y.output_range[0],\n        x2=svg.w - margin[\"r\"],\n        y2=scale_y.output_range[0],\n        stroke=\"black\",\n    )\n)\n\n# Optionally, create tick markers\npolyline_points = []\nfor ix in x_values_indices:\n    polyline_points.extend([x_values[ix], scale_y.output_range[0]])\n\npolyline = dp.Polyline(polyline_points, stroke=\"none\", fill=\"none\")\nlayer0.append(polyline)\n\nmarker = Marker(\"bottom-tick\", TICK_BOTTOM, 10, 10)\ndefs.append(marker)\npolyline.marker_start = marker.id_ref\npolyline.marker_mid = marker.id_ref\npolyline.marker_end = marker.id_ref\n\n# Add text labels for each tick\nfor ix in x_values_indices:\n    tick_date = pendulum.instance(dates[ix])\n    tick_label = dp.Text(\n        tick_date.format(\"D MMM 'YY\"),  # e.g. \"2 Jul '24\"\n        x=x_values[ix],\n        y=scale_y.output_range[0] + 30,\n        font_family=\"Roboto\",\n        font_size=16,\n        fill=\"black\",\n        text_anchor=\"middle\",\n    )\n    layer0.append(tick_label)\n</code></pre> <p></p>"},{"location":"blog/2025/02/25/line-chart/#creating-the-y-axis-and-grid-lines","title":"Creating the Y-Axis and Grid Lines","text":"<p>We\u2019ll generate about 5 ticks on the Y-axis and draw horizontal grid lines for each. Then, we add numeric labels to the left side.</p> <pre><code># Generate ~5 evenly spaced ticks for the Y-axis\n# Generate ~5 evenly spaced ticks for the Y-axis\nticks = calculate_ticks(min_value, max_value, 5)\nprint(\"Y Ticks:\", ticks)\n\nfor tick in ticks:\n    y = scale_y.map(tick)\n\n    # Horizontal grid line\n    layer0.append(\n        dp.Line(x1=margin[\"l\"], y1=y, x2=svg.w - margin[\"r\"], y2=y, stroke=\"#e0e0e0\")\n    )\n\n    # Tick label\n    tick_text = dp.Text(\n        str(tick),\n        x=margin[\"l\"] - 10,\n        y=y + 4,\n        font_family=\"Roboto\",\n        font_size=16,\n        text_anchor=\"end\",\n    )\n    layer0.append(tick_text)\n</code></pre> <p>At this point, the svg object holds all of our chart elements. Depending on your environment, you might:</p> <ul> <li>Save the SVG to a file: <pre><code>svg.save_svg(\"line_chart.svg\")\n</code></pre></li> <li>Render it directly in a notebook environment that supports inline SVG. The final result should look like this:</li> </ul> <p></p>"},{"location":"blog/2025/02/25/line-chart/#conclusion","title":"Conclusion","text":"<p>Congratulations! You\u2019ve created a multi-line chart using Polars for data manipulation and pydreamplet for SVG rendering. You learned how to:</p> <ul> <li>Generate synthetic data using <code>Noise</code>,</li> <li>Build a Polars <code>DataFrame</code> and identify min/max values,</li> <li>Set up SVG canvas and scales,</li> <li>Draw polylines for each product,</li> <li>Label each line and axis ticks,</li> <li>Add horizontal grid lines.</li> </ul> <p>Feel free to experiment with different color schemes, font sizes, or data intervals. You can also add interactive tooltips or other enhancements to make your chart even more dynamic.</p> <p>Happy charting!</p>"},{"location":"blog/2025/02/11/waffle-chart/","title":"Waffle Chart","text":"<p>Everyone knows that pie charts are overused. This example shows how to quickly build the waffle chart.</p> Waffle chart <p>First, let's import the necessary components.</p> <pre><code>import pydreamplet as dp\nfrom pydreamplet.colors import random_color\n</code></pre> <p>Then we also need some data (sorted).</p> <pre><code>data = [130, 65, 108]\ndata.sort(reverse=True)\n</code></pre> <p>We define the square size, gutter, and how many squares we want to have on every side. Usually, we want to show the share in %, therefore a reasonable choice is to have a 10 by 10 chart. We also need to know the sum of values from the given dataset.</p> <pre><code>side = 300\nside_count = 10\ngutter = 5\ntotal_cells = side_count ** 2\ntotal = sum(data)\n</code></pre> <p>Next, we have to calculate how many cells each group should fill.</p> <pre><code>proportions = [int(round(d / total * total_cells, 0)) for d in data]\n</code></pre> <p>Now we have to compute the cell size, ensuring gutters on both sides.</p> <pre><code>cell_side = (side - (side_count + 1) * gutter) / side_count\n</code></pre> <p>Create a list that maps each square index to a group (color).</p> <pre><code>cell_group_map = []\nfor group_index, count in enumerate(proportions):\n    cell_group_map.extend([group_index] * count)\n</code></pre> <p>If there's any discrepancy, fill the rest with a default group (optional).</p> <pre><code>if len(cell_group_map) &lt; total_cells:\n    cell_group_map.extend([None] * (total_cells - len(cell_group_map)))\n</code></pre> <p>Create a separate path for each group.</p> <pre><code>paths = {i: \"\" for i in range(len(data))}\n</code></pre> <p>Loop over all squares using index-based placement. You can determine the row and column index using modulo and floor division (lines 19-20). Remember to only draw if the cell belongs to a group (not left as None; see lines 25-27).</p> <pre><code>for i in range(total_cells):\n    col = i % side_count\n    row = i // side_count\n\n    x = gutter + col * (cell_side + gutter)\n    y = gutter + row * (cell_side + gutter)\n\n    group = cell_group_map[i]\n    if group is not None:\n        paths[group] += f\"M {x} {y} h {cell_side} v {cell_side} h -{cell_side} Z \"\n</code></pre> <p>Create an SVG element with the specified dimensions.</p> <pre><code>svg = dp.SVG(side, side)\n</code></pre> <p>And finally, append each group's path element to the SVG.</p> <pre><code>for group_index, d_str in paths.items():\n    if d_str:\n        path = dp.Path(d=d_str, fill=random_color())\n        svg.append(path)\n</code></pre> <p>That's it. If you are using Jupyter Notebook, you can render your chart using <code>svg.display()</code>. Alternatively, save your chart to a file.</p> <pre><code>svg.save(\"waffle_chart.svg\")\n</code></pre>"},{"location":"getting_started/","title":"Installation and quick intro","text":"<p>pyDreamplet is a Python library designed for creating stunning SVG visualizations effortlessly. This guide covers installation, basic usage, and pointers for exploring additional features to help create captivating visual art with code.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"uvpip <pre><code>uv add pydreamplet\n</code></pre> <pre><code>pip install pydreamplet\n</code></pre>"},{"location":"getting_started/#basic-example","title":"Basic Example","text":"<p>The following example demonstrates how to create a simple SVG canvas, draw a shape, and save the result to a file.</p> Your first SVG<pre><code>import pydreamplet as dp\nfrom pydreamplet.colors import random_color\n\nsvg = dp.SVG(300, 300)\n\ncircle = dp.Circle(\n    cx=svg.w/2,\n    cy=svg.h/2,\n    r=100,\n    fill=random_color(),\n)\nsvg.append(circle)\n\nsvg.display()  # to display result in jupyter notebook\n\nsvg.save(\"example.svg\")\n</code></pre> <p>This will create such a image</p> <p></p> <p>pyDreamplet provides various functions to generate complex visuals, such as:</p> <ul> <li>Drawing Multiple Shapes: Create combinations of lines, circles, and custom paths.</li> <li>Styling Options: Apply gradients, patterns, and advanced styling techniques.</li> <li>Animations: If supported, add animation effects to SVG elements.</li> </ul> <p>Let's take a look at a little more interesting example. In this snippet, we create a 600\u00d7600 SVG canvas and build an animated radial design with 35 circles. Each circle animates its position and size, while its stroke color transitions smoothly from black to red. Here\u2019s a detailed breakdown:</p> <p>First, import <code>pydreamplet</code> and scales.</p> <pre><code>import pydreamplet as dp\nfrom pydreamplet.scales import LinearScale, ColorScale\n</code></pre> <p>Next, we create a 600\u00d7600 SVG canvas. A group element (<code>G</code>) is defined with its position set at the center of the canvas. This ensures that all contained elements are rendered relative to the center, making the radial design easier to manage.</p> <pre><code>svg = dp.SVG(600, 600)\ng = dp.G(pos=dp.Vector(svg.w / 2, svg.h / 2))\nsvg.append(g)\n</code></pre> <p>We define the total number of circles (<code>circles_count</code>) and set the minimum and maximum radius values. The <code>LinearScale</code> maps the circle\u2019s index (from 0 to 35) to a radius that varies between <code>min_radius</code> and <code>max_radius</code>. Similarly, the <code>ColorScale</code> maps these indices to a color gradient from black to red.</p> <pre><code>circles_count = 35\nmax_radius = 250\nmin_radius = 5\nr_scale = LinearScale((0, circles_count - 1), (min_radius, max_radius))\ncolor_scale = ColorScale((0, circles_count - 1), (\"#000000\", \"#FF0000\"))\n</code></pre> <p>We start from a point on the right of an imaginary circle (at the maximum radius) and then loop over the total number of circles. For each iteration:</p> <ul> <li>A circle is created with no fill and a stroke color determined by its index.</li> <li>Animations are added to the circle for the x (<code>cx</code>) and y (<code>cy</code>) coordinates. These animate the circle\u2019s center from its starting position to the center of the canvas and then back.</li> <li>The circle\u2019s radius is animated from a minimum value to a computed value (using the linear scale) and back.</li> <li>The starting position is rotated slightly (by 360\u00b0 divided by the total number of circles) for the next circle, creating the radial layout.</li> </ul> <pre><code>start_pos = dp.Vector(max_radius, 0)\nfor i in range(circles_count):\n    # Create a circle with a dynamic stroke color.\n    c = dp.Circle(fill=\"none\", stroke=color_scale.map(i))\n    c.pos = start_pos\n\n    # Animate the circle's horizontal and vertical positions.\n    pos_x_anim = dp.Animate(\"cx\", values=[start_pos.x, 0, start_pos.x], dur=\"5s\")\n    pos_y_anim = dp.Animate(\"cy\", values=[start_pos.y, 0, start_pos.y], dur=\"5s\")\n\n    # Rotate the starting position for the next circle.\n    start_pos.direction += 360 / circles_count\n\n    # Animate the circle's radius using the linear scale.\n    r_anim = dp.Animate(\"r\", values=[min_radius, r_scale.map(i), min_radius], dur=\"5s\")\n\n    # Append animations to the circle.\n    c.append(pos_x_anim)\n    c.append(pos_y_anim)\n    c.append(r_anim)\n\n    # Add the circle to the group.\n    g.append(c)\n</code></pre> <p>Finally, we can render the SVG. In environments like Jupyter Notebook, calling <code>svg.display()</code> will show the animated visualization directly in your notebook. Alternatively, you can save your art by calling <code>svg.save(\"circles.svg\")</code>.</p> <p></p> <p>For detailed information on all available functions and parameters, consult the API reference.</p> <p>Next steps</p> <ul> <li>Experiment with Examples: Modify the basic example by adding new shapes or changing colors to see different effects.</li> <li>Check the tutorial.</li> <li>Review the API Documentation: Learn about the full range of functions available in pyDreamplet.</li> <li>Explore the Blog: Discover advanced examples and creative projects that showcase the library\u2019s capabilities.</li> </ul>"},{"location":"getting_started/basics/","title":"Basics","text":"<p>In this section, you will get familiar with the basic functionality.</p>"},{"location":"getting_started/basics/#creating-an-svg-instance","title":"Creating an SVG Instance","text":""},{"location":"getting_started/basics/#empty-svg","title":"Empty SVG","text":"<p>You have two options to create an SVG instance. The first one is an empty SVG.</p> <pre><code>import pydreamplet as dp\n\nsvg = dp.SVG(400, 300)\nprint(svg)  # &lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 300\" width=\"400px\" height=\"300px\" /&gt;\n</code></pre> <p>If you need to change <code>x</code> and <code>y</code> of the <code>viewBox</code>, you can do so by providing four arguments or a tuple with all four values.</p> <pre><code>svg = dp.SVG(10, 10, 400, 300)\nprint(svg)  # &lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"10 10 400 300\" width=\"400px\" height=\"300px\" /&gt;\n</code></pre> <p>You can see that the width and height are automatically set to the width and height of the <code>viewBox</code> with the <code>px</code> unit. You can change this by explicitly specifying the width and height.</p> <pre><code>svg = dp.SVG(400, 300, width=\"800px\", height=\"600px\")\nprint(svg)  # &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"800px\" height=\"600px\" viewBox=\"0 0 400 300\" /&gt;\n</code></pre>"},{"location":"getting_started/basics/#svg-instance-from-existing-file","title":"SVG Instance From Existing File","text":"<p>You can also create a new instance from an existing SVG file. To do so, you must use the class method <code>from_file</code>.</p>"},{"location":"getting_started/basics/#creating-svg-elements","title":"Creating SVG Elements","text":"<p>You can create any SVG element using the <code>SvgElement</code> class. However, use <code>SvgElement</code> only if there is no dedicated class for that specific element. Check the reference to see which classes are available. Let\u2019s look at an example.</p> <p>This code:</p> <pre><code>svg = dp.SVG(400, 300)\ncircle = dp.SvgElement(\"circle\", cx=200, cy=150, r=100, fill=\"#1b313b\")\nsvg.append(circle)\n</code></pre> <p>will produce the same result as:</p> <pre><code>svg = dp.SVG(400, 300)\ncircle = dp.Circle(cx=200, cy=150, r=100, fill=\"#1b313b\")\nsvg.append(circle)\n</code></pre> <p>Both snippets create the following file:</p> <p></p> <p>However:</p> <pre><code>circle = dp.Circle(cx=200, cy=150, r=100, fill=\"#1b313b\")\nprint(circle.area)\n</code></pre> <p>will print the area of the circle, while:</p> <pre><code>circle = dp.SvgElement(\"circle\", cx=200, cy=150, r=100, fill=\"#1b313b\")\nprint(circle.area) # Will not work\n</code></pre> <p>raises an <code>AttributeError: 'SvgElement' object has no attribute 'area'</code></p>"},{"location":"getting_started/basics/#changing-element-attributes","title":"Changing Element Attributes","text":"<p>You can set or change the attributes of SVG elements in a few different ways. The first is by passing keyword arguments (<code>kwargs</code>) to the constructor, as shown in the previous examples.</p> <p>An alternative method is to use instance properties:</p> <pre><code>svg = dp.SVG(400, 300)\ncircle = dp.SvgElement(\"circle\", cx=200, cy=150, r=100)\ncircle.fill = \"none\"\ncircle.stroke = \"#a00344\"\ncircle.stroke_width = 5\nsvg.append(circle)\n</code></pre> <p></p> <p>Notice that while the SVG specification uses hyphens in attribute names (e.g., <code>stroke-width</code>), the corresponding instance properties use underscores (e.g., <code>stroke_width</code>).</p> <p>The third method is to use the <code>attrs</code> function. The following code:</p> <pre><code>svg = dp.SVG(400, 300)\ncircle = dp.SvgElement(\"circle\", cx=200, cy=150, r=100)\ncircle.attrs({\"fill\": \"none\", \"stroke\": \"#a00344\", \"stroke-width\": 5})\nsvg.append(circle)\n</code></pre> <p>produces the same file.</p>"},{"location":"getting_started/basics/#building-the-svg-tree","title":"Building the SVG tree","text":"<p>You can append any element\u2014or multiple elements at once\u2014using the <code>append</code> method. You saw this when we appended a circle in the examples above. There are other useful methods, such as <code>remove</code>, <code>find</code>, and <code>find_all</code>. Let's see them in action.</p> <p>First, we create a new SVG with 5 circles.</p> <pre><code>import pydreamplet as dp\n\nsvg = dp.SVG(400, 200)\nfor i in range(5):\n    svg.append(\n        dp.Circle(\n            cx=100 + i * 50,\n            cy=100,\n            r=20,\n            fill=\"#a00344\",\n            id=f\"circle-{i + 1}\",\n            class_name=\"even\" if i % 2 == 0 else \"odd\",\n        )\n    )\n</code></pre> <p>This creates the following SVG structure. Remember that <code>class</code> is a reserved word in Python, which is why we use the property <code>class_name</code>.</p> <pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 200\" width=\"400px\" height=\"200px\"&gt;\n  &lt;circle cx=\"100\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-1\" class=\"even\" /&gt;\n  &lt;circle cx=\"150\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-2\" class=\"odd\" /&gt;\n  &lt;circle cx=\"200\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-3\" class=\"even\" /&gt;\n  &lt;circle cx=\"250\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-4\" class=\"odd\" /&gt;\n  &lt;circle cx=\"300\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-5\" class=\"even\" /&gt;\n&lt;/svg&gt;\n</code></pre> <p></p> <p>Now we can change the properties of the odd circles.</p> <pre><code>odd = svg.find_all(\"circle\", class_name=\"odd\")\nfor circle in odd:\n    circle.fill = \"none\"\n    circle.stroke = \"#000000\"\n</code></pre> <p></p> <p>Warning</p> <p>We use the string \"none\", not Python's None, because None is used to remove an attribute. The code</p> <p> <pre><code>odd = svg.find_all(\"circle\", class_name=\"odd\")\nfor circle in odd:\n    circle.fill = None\n    circle.stroke = \"#000000\"\n</code></pre> will remove the fill attribute completely, and the circles will then have the default black fill.</p> <pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 200\" width=\"400px\" height=\"200px\"&gt;\n&lt;circle cx=\"100\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-1\" class=\"even\" /&gt;\n&lt;circle cx=\"150\" cy=\"100\" r=\"20\" id=\"circle-2\" class=\"odd\" stroke=\"#000000\" /&gt;\n&lt;circle cx=\"200\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-3\" class=\"even\" /&gt;\n&lt;circle cx=\"250\" cy=\"100\" r=\"20\" id=\"circle-4\" class=\"odd\" stroke=\"#000000\" /&gt;\n&lt;circle cx=\"300\" cy=\"100\" r=\"20\" fill=\"#a00344\" id=\"circle-5\" class=\"even\" /&gt;\n&lt;/svg&gt;\n</code></pre> <p></p> <p>Now, let's remove the middle circle.</p> <pre><code>middle = svg.find(\"circle\", id=\"circle-3\")\nsvg.remove(middle)\n</code></pre> <p></p>"},{"location":"getting_started/tutorial/","title":"Tutorial","text":"<p>Creating Layered and Animated SVG Art with pydreamplet</p> <p>In this tutorial, we use the pydreamplet library to generate an SVG artwork that features two layers. One layer holds a series of arcs with blended colors, and the other contains an animated circle enhanced by a linear gradient. The code demonstrates how to import necessary modules, organize elements into groups, and add both static and animated components.</p>"},{"location":"getting_started/tutorial/#importing-libraries-and-defining-colors","title":"Importing Libraries and Defining Colors","text":"<p>We begin by importing the core pydreamplet module and specific helpers for creating arc paths and blending colors. We also define four color variables that are used later for color blending and gradients.</p> <pre><code>import pydreamplet as dp\nfrom pydreamplet.shapes import ring\nfrom pydreamplet.colors import blend\n\n# Define the colors used in the design\ncolor1 = \"#e2cbc5\"\ncolor2 = \"#691016\"\ncolor3 = \"#92a1c2\"\ncolor4 = \"#082137\"\n</code></pre>"},{"location":"getting_started/tutorial/#setting-up-the-svg-canvas-and-groups-layers","title":"Setting Up the SVG Canvas and Groups (Layers)","text":"<p>We create an SVG canvas of 600\u00d7600 units, then set its display size to 300\u00d7300 pixels. We also create two group elements (layers) to control the stacking order of our elements.</p> <ul> <li>layer0 is used for the animated circle.</li> <li>layer1 holds all the arcs.</li> </ul> <pre><code># Create an SVG canvas with a viewBox of 600x600 and set display dimensions\nsvg = dp.SVG(600, 600)\nsvg.width = \"300px\"\nsvg.height = \"300px\"\n\n# Create two groups to manage layering:\n# layer0 for the animated circle, layer1 for the arcs\nlayer0 = dp.G()\nlayer1 = dp.G()\nsvg.append(layer0).append(layer1)\n</code></pre> <p>Using groups allows you to separately control transformations or styling of different sets of elements.</p>"},{"location":"getting_started/tutorial/#drawing-the-arcs-layer1","title":"Drawing the Arcs (Layer1)","text":"<p>Two loops create arcs that form the bottom and top halves of a circle. The arcs are generated with a decreasing radius and blended colors for a gradient-like effect.</p>"},{"location":"getting_started/tutorial/#top-half-arcs","title":"Top-Half Arcs","text":"<p>For the top half, arcs are drawn from 180\u00b0 to 360\u00b0. The starting x-coordinate is at the canvas center and shifts left on each iteration. The radius shrinks gradually, and the blend proportion increases to interpolate between <code>color1</code> and <code>color2</code>.</p> <pre><code># Initialize parameters for the top half arcs\nx = svg.w / 2          # Starting at the horizontal center\nblend_prop = 0         # Initial blend proportion for color blending\nradius = 200           # Initial radius for arcs\nradius_delta = radius / 6  # Amount to reduce the radius on each loop\n\nfor i in range(6):\n    # Create an arc for the top half using the ring function\n    arc = dp.Path(\n        d=ring(\n            x,\n            svg.h / 2,          # y-coordinate remains centered\n            inner_radius=0,     # arcs start from the center\n            outer_radius=radius, \n            start_angle=180,    # start at 180\u00b0 (left side)\n            end_angle=360,      # end at 360\u00b0 (completing the top half)\n        ),\n    )\n    # Set the arc's fill by blending color1 and color2\n    arc.fill = blend(color1, color2, blend_prop)\n    # Update parameters for next arc: shift x left, decrease radius, and increase blend proportion\n    x -= radius_delta\n    radius -= radius_delta\n    blend_prop += 1 / 6\n    # Append arc to the group for arcs (layer1)\n    layer1.append(arc)\n</code></pre> Each iteration creates an arc with slightly different dimensions and a gradually changing fill color."},{"location":"getting_started/tutorial/#bottom-half-arcs","title":"Bottom-Half Arcs","text":"<p>The next loop draws the bottom half from 0\u00b0 to 180\u00b0. Here, the x-coordinate shifts right on each iteration, and the fill color blends between <code>color3</code> and <code>color4</code>.</p> <pre><code># Reset parameters for the bottom half arcs\nx = svg.w / 2          # Restart from the center\nblend_prop = 0         # Reset blend proportion\nradius = 200           # Reset radius to initial value\n\nfor i in range(6):\n    # Create an arc for the bottom half using the ring function\n    arc = dp.Path(\n        d=ring(\n            x,\n            svg.h / 2,\n            inner_radius=0,\n            outer_radius=radius,\n            start_angle=0,    # start at 0\u00b0 (right side)\n            end_angle=180,    # end at 180\u00b0 (completing the bottom half)\n        ),\n    )\n    # Set the arc's fill by blending color3 and color4\n    arc.fill = blend(color3, color4, blend_prop)\n    # Update parameters for the next arc: shift x right, decrease radius, and increase blend proportion\n    x += radius_delta\n    radius -= radius_delta\n    blend_prop += 1 / 6\n    # Append arc to layer1\n    layer1.append(arc)\n</code></pre> Together, these two loops produce a layered effect with complementary color transitions on both halves of the circle."},{"location":"getting_started/tutorial/#adding-an-animated-circle-with-gradient-fill-layer0","title":"Adding an Animated Circle with Gradient Fill (Layer0)","text":"<p>An animated circle is created to overlay the arcs. It features:</p> <ul> <li><code>Animation:</code> Two animations \u2013 one for the stroke-dashoffset (moving dashes) and one for the circle\u2019s radius (pulsating effect).</li> <li><code>Gradient Fill:</code> A linear gradient defined in the <code>&lt;defs&gt;</code> section, applied as the circle\u2019s fill.</li> <li><code>Stroke Styling:</code> The stroke is set to \"gray\" to enhance the contrast.</li> </ul>"},{"location":"getting_started/tutorial/#creating-the-animated-circle","title":"Creating the Animated Circle","text":"<p>Place the circle in layer0 to ensure it sits behind the arcs.</p> <pre><code># Create a circle with a radius of 250, dashed stroke, and no initial fill\ncircle = dp.Circle(\n    r=250,\n    fill=\"none\",\n    stroke=\"black\",\n    stroke_width=5,\n    stroke_dasharray=\"20,15\",\n    stroke_dashoffset=20\n)\n# Position the circle at the center of the canvas\ncircle.pos = dp.Vector(svg.w / 2, svg.h / 2)\n\n# Define an animation for stroke-dashoffset to create moving dashes\nanimate = dp.Animate(attr=\"stroke-dashoffset\", dur=\"2s\")\nanimate.values = [0, 100]\n\n# Define an animation for the circle's radius for a pulsating effect\naniate2 = dp.Animate(attr=\"r\", dur=\"2s\")\naniate2.values = [250, 200, 250]\n\n# Append the animations to the circle\ncircle.append(animate)\ncircle.append(aniate2)\n\nlayer0.append(circle)\n</code></pre> The animations run continuously, making the circle appear to breathe and animate its dashed stroke."},{"location":"getting_started/tutorial/#defining-and-applying-a-linear-gradient","title":"Defining and Applying a Linear Gradient","text":"<p>A linear gradient is defined to enhance the circle\u2019s fill. The gradient transitions from <code>color3</code> to <code>color1</code> and is rotated by 90\u00b0.</p> <pre><code># Create a linear gradient element with a rotation transform\ngrad = dp.SvgElement(\"linearGradient\", id=\"grad\", gradientTransform=\"rotate(90)\")\n# Define the starting color stop at 0%\ngrad.append(dp.SvgElement(\"stop\", offset=\"0%\", style=f\"stop-color:{color3};stop-opacity:1\"))\n# Define the ending color stop at 100%\ngrad.append(dp.SvgElement(\"stop\", offset=\"100%\", style=f\"stop-color:{color1};stop-opacity:1\"))\n\n# Wrap the gradient definition in a defs element\ndefs = dp.SvgElement(\"defs\")\ndefs.append(grad)\n# Append the defs element to the SVG canvas so that the gradient is recognized\nsvg.append(defs)\n</code></pre> <p>The gradient is now available with the ID \"grad\" and can be applied to any shape using a fill of \"url(#grad)\".</p>"},{"location":"getting_started/tutorial/#updating-the-circles-styling-and-layer-placement","title":"Updating the Circle\u2019s Styling and Layer Placement","text":"<p>After creating the gradient, update the circle's fill to use the gradient and change its stroke to \"gray\".</p> <pre><code># Apply the gradient fill to the circle and update its stroke color\ncircle.fill = \"url(#grad)\"\ncircle.stroke = \"gray\"\n\nsvg.display() # in jupyter notebook\n</code></pre> Final Output  <p>This completes the SVG artwork, which now consists of a layered composition of blended arcs and an animated, gradient-filled circle.</p>"},{"location":"getting_started/vector_transformations/","title":"Vector transformations","text":""},{"location":"getting_started/vector_transformations/#vector-math","title":"Vector math","text":"<p>You can control the position of elements like <code>Circle</code>, <code>Ellipse</code>, <code>Rect</code>, <code>Text</code>, and even groups (<code>G</code>) using vector operations. In the case of a <code>G</code> element, vectors are additionally used to control scaling and the pivot point for rotation.</p> <p>Consider the following example:</p> <pre><code>from pydreamplet import Circle, G, SVG, Text, Vector\n\nsvg = SVG(400, 300)\norigin = G(id=\"origin\")\nsvg.append(origin)\norigin.append(\n    Circle(cx=0, cy=0, r=5, fill=\"red\"),\n    Text(\"0, 0\", x=10, y=0, dominant_baseline=\"middle\"),\n)\n</code></pre> <p></p> <p>The SVG\u2019s origin is at the top left, so much of the content is off-screen. To center it, you can transform the origin (<code>&lt;g&gt;</code> element) like so:</p> <pre><code>origin.pos += Vector(svg.w / 2, svg.h / 2)\n</code></pre> <p></p> <p>Now let\u2019s add a circle relative to the new origin. We define a vector for its position:</p> <pre><code>circle_pos = Vector(100, 0)\norigin.append(Circle(pos=circle_pos, r=15, fill=\"#a00344\"))\n</code></pre> <p></p> <p>Next, you can use vector math to add additional circles evenly spaced around the origin. By incrementing the vector\u2019s direction by 72\u00b0 each time, you form a ring of 5 circles:</p> <pre><code>for _ in range(4):\n    circle_pos.direction += 72\n    origin.append(Circle(pos=circle_pos, r=15, fill=\"#a00344\"))\n</code></pre> <p></p>"},{"location":"getting_started/vector_transformations/#transformation-order","title":"Transformation order","text":"<p>When combining multiple transformations\u2014translation, rotation, and scaling\u2014the order in which they are applied is critical. In the <code>pydreamplet</code> library, the transformation order is controlled by the <code>order</code> property on a group (or container) element.</p>"},{"location":"getting_started/vector_transformations/#initial-setup","title":"Initial setup","text":"<p>First, we load an SVG file containing a hummingbird, change its fill color, and then add it to an SVG canvas:</p> <pre><code>from importlib.resources import files\nfrom pydreamplet import SVG, G, resources, Vector\n\n# Load the hummingbird SVG and change its fill color\nhummingbird = SVG.from_file(files(resources) / \"hummingbird.svg\").find(\"path\")\nhummingbird.fill = \"#a00344\"\n\n# Create a new SVG canvas and group element; append the hummingbird to the group\nsvg = SVG(400, 300)\ng = G()\nsvg.append(g.append(hummingbird))\n</code></pre> <p></p>"},{"location":"getting_started/vector_transformations/#applying-transformations","title":"Applying Transformations","text":"<p>Suppose we want to:</p> <ul> <li>Rotate the hummingbird by 30 degrees,</li> <li>Scale it by a factor of 5,</li> <li>Translate (move) it so that it is centered on the canvas.</li> </ul> <p>We can achieve this by setting the transformation order and properties on the group 'g':</p> <pre><code># Specify the transformation order: Translate -&gt; Rotate -&gt; Scale\ng.order = \"trs\"  # demo only, because this is the default order\n\n# Define scaling factor and the center of the hummingbird in its original coordinate space\nscale = 5\nhummingbird_center = Vector(12, 10)\n\n# Set the pivot point for rotation.\n# The pivot is adjusted by the scale factor because the transformations will scale the coordinate system.\ng.pivot = hummingbird_center * scale\n\n# Apply a rotation of 30 degrees\ng.angle = 30\n\n# Move (translate) the group so that the scaled hummingbird centers in the SVG canvas.\ng.pos += Vector(svg.w / 2, svg.h / 2) - hummingbird_center * scale\n\n# Apply scaling uniformly in both x and y directions\ng.scale = Vector(scale, scale)\n</code></pre> <p></p>"},{"location":"getting_started/vector_transformations/#how-transformation-order-works","title":"How Transformation Order Works","text":"<p>The order property determines the sequence in which the three types of transformations are applied. In our example:</p> <ul> <li><code>T</code> (Translate): Moves the element first.</li> <li><code>R</code> (Rotate): Rotates the element around its pivot point after it has been moved.</li> <li><code>S</code> (Scale): Finally, scales the element relative to its pivot.</li> </ul> <p>This sequence can be modified by changing the <code>order</code> string. For instance, if we set:</p> <pre><code>g.order = \"rts\"  # Rotate -&gt; Translate -&gt; Scale\n</code></pre> <p>the element would first be rotated, then translated, and finally scaled. Because these operations are not commutative, changing their order will lead to a different final appearance:</p> <p></p>"},{"location":"getting_started/vector_transformations/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>Transformation Order Matters:</code> The final position, orientation, and size of an element depend on the order of translation, rotation, and scaling.</li> <li><code>Pivot Point:</code> Setting the pivot correctly is essential, as both rotation and scaling are performed around this point.</li> <li>E<code>xperimentation:</code> Changing the <code>order</code> property (e.g., from <code>\"trs\"</code> to <code>\"rts\"</code>) can yield significantly different results, so choose the order that achieves your desired effect.</li> </ul>"},{"location":"getting_started/working_with_text/","title":"Working with text","text":"<p>Below is a step-by-step tutorial on how to measure and visualize text dimensions using pyDreamplet. We\u2019ll cover:</p> <ul> <li>Overview of text measurement</li> <li>Creating an SVG canvas and adding text</li> <li>Measuring text using <code>TypographyMeasurer</code></li> <li>Visualizing bounding boxes</li> <li>Tips &amp; tricks for more accurate results</li> </ul>"},{"location":"getting_started/working_with_text/#overview-of-text-measurement","title":"Overview of Text Measurement","text":"<p>When working with text in pyDreamplet, you often need to know the approximate dimensions of the text to handle layout correctly. For instance, if you want to center text within a rectangle or place shapes around your text, you must know how wide and tall the text will be.</p> <p>pyDreamplet uses Pillow (the Python Imaging Library) to compute this estimate. Pillow\u2019s text measurement is not as precise as layout engines like a web browser (e.g., using <code>&lt;canvas&gt;</code> or <code>SVG</code> in an actual HTML environment), but it is lightweight and good enough for most design tasks.</p> <p>Key points about measurement:</p> <ul> <li>Measurements are approximate.</li> <li>Complex or uncommon fonts may yield slightly inconsistent results.</li> <li>You have control over font family, font size, and font weight.</li> </ul>"},{"location":"getting_started/working_with_text/#creating-an-svg-canvas-and-adding-text","title":"Creating an SVG Canvas and Adding Text","text":"<p>Below is a minimal example of how to create an SVG canvas and place a text label in the center. We will go step by step.</p> <pre><code>import pydreamplet as dp\nfrom pydreamplet.typography import TypographyMeasurer\n\n# 1. Create an SVG with specified width and height\nsvg = dp.SVG(400, 200)\n\n# 2. Create a group (dp.G) positioned at the center of the canvas.\n#    We'll use this group to append our shapes and text so that\n#    everything is centered relative to this position.\ng = dp.G(dp.Vector(svg.w / 2, svg.h / 2))\nsvg.append(g)\n\n# 3. (Optional) Add a small circle to visualize the center point.\ncenter = dp.Circle(pos=dp.Vector(0, 0), r=5, fill=\"red\")\ng.append(center)\n\n# 4. Create your text element.\ntxt = dp.Text(\"pyDreamplet\")\ntxt.font_family = \"Verdana\"\ntxt.font_size = \"48\"\ntxt.font_weight = 700\ntxt.text_anchor = \"middle\"\ntxt.dominant_baseline = \"middle\"\n\n# Append the text element to the group\ng.append(txt)\n</code></pre> <p></p>"},{"location":"getting_started/working_with_text/#understanding-text-properties","title":"Understanding Text Properties","text":"<ul> <li><code>font_family</code>: The font used to render the text (e.g., <code>\"Verdana\"</code>, <code>\"Arial\"</code>).</li> <li><code>font_size</code>: The size of the text in points.</li> <li><code>font_weight</code>: Use a numeric value like <code>400</code> (normal) or <code>700</code> (bold).</li> <li><code>text_anchor</code>: Determines horizontal alignment. Common values are:<ul> <li><code>start</code> (left-aligned),</li> <li><code>middle</code> (center-aligned),</li> <li><code>end</code> (right-aligned).</li> </ul> </li> <li><code>dominant_baseline</code>: Determines vertical alignment. Common values are:<ul> <li><code>alphabetic</code> (default baseline),</li> <li><code>middle</code> (centers the text vertically relative to its bounding box),</li> <li><code>hanging</code>,</li> <li><code>baseline</code> (similar to alphabetic).</li> </ul> </li> </ul> <p>At this point, we already have our text placed at the center of the SVG. However, we might want to see how large it is in order to align other shapes around it.</p>"},{"location":"getting_started/working_with_text/#measuring-text-using-typographymeasurer","title":"Measuring Text Using TypographyMeasurer","text":"<p>To measure the width and height of any text string, pyDreamplet provides the TypographyMeasurer class. Under the hood, it uses Pillow for measurement:</p> <pre><code>measurer = TypographyMeasurer()\n\nwidth, height = measurer.measure_text(\n    txt.content,\n    font_family=txt.font_family,\n    font_size=txt.font_size,\n    weight=txt.font_weight\n)\n\nprint(f\"Measured text width: {width}, height: {height}\") #  prints Width: 347.0, Height: 47.0\n</code></pre> <ul> <li><code>txt.content</code> is the string you want to measure.</li> <li><code>font_family=txt.font_family</code>, <code>font_size=txt.font_size</code>, and <code>weight=txt.font_weight</code> match the same styling you set on your <code>Text</code> object.</li> </ul> <p>The returned <code>width</code> and <code>height</code> are floating-point values representing the approximate bounding box in pixels.</p>"},{"location":"getting_started/working_with_text/#visualizing-bounding-boxes","title":"Visualizing Bounding Boxes","text":"<p>Often, it helps to draw a rectangle around the text to see exactly how it\u2019s placed. We can use the measured <code>width</code> and <code>height</code> for that.</p> <pre><code># Create a rectangle based on the measured text dimensions\nrect = dp.Rect(\n    pos=dp.Vector(-width / 2, -height / 2),\n    width=width,\n    height=height,\n    fill=\"none\",\n    stroke=\"blue\",\n    stroke_width=1,\n)\n\n# Append the rectangle to the same group\ng.append(rect)\n</code></pre> <p>Because we used <code>text_anchor=\"middle\"</code> and <code>dominant_baseline=\"middle\"</code>, the text\u2019s center aligns with the origin of the <code>G</code> group (which we placed at the center of the SVG). Hence, to align our rectangle with the text:</p> <ul> <li>We offset its position by <code>-width/2</code> and <code>-height/2</code>.</li> <li>This ensures the rectangle\u2019s center is also at <code>(0,0)</code>.</li> </ul> <p>Your final output might look like this:</p> <p></p>"},{"location":"getting_started/working_with_text/#tips-tricks-for-more-accurate-results","title":"Tips &amp; Tricks for More Accurate Results","text":"<p>Use the same font settings Make sure you pass the exact same font properties (font_family, font_size, font_weight, etc.) to both your Text element and to the TypographyMeasurer. If there is a mismatch, your measured dimensions will not match the on-screen text.</p> <p>Mind the environment Some systems may have different font renderers or default fonts when the specified font is unavailable. Verify that Pillow can find the font you\u2019re requesting. If it can\u2019t, it might fall back to a default (often DejaVuSans).</p> <p>Adjust for vertical offsets Depending on the chosen dominant_baseline, the text might render slightly differently than the bounding box you expect. If precise alignment is crucial, experiment with different baseline settings or manually offset using dy or the pos property.</p> <p>Measuring multiple lines If you have multiline text, consider measuring each line separately or measure the joined lines with newline characters (\"\\n\"). Keep in mind that line spacing might not be accurately reflected by Pillow. You may need to add additional spacing based on your design needs.</p> <p>Performance considerations Measuring text repeatedly can be somewhat expensive. If you are repeatedly measuring the same text (e.g., in a loop), cache the result.</p>"},{"location":"reference/colors/","title":"Color utilities","text":"<p>This module provides various utility functions for color conversion, manipulation, and random color generation.</p>"},{"location":"reference/colors/#hexstr","title":"<code>hexStr</code>","text":"<pre><code>hexStr(n: int) -&gt; str\n</code></pre> <p>Converts an integer (0-255) to a two-digit hexadecimal string.</p> <p>Parameters</p> <ul> <li><code>n</code> (int): An integer value between 0 and 255.</li> </ul> <pre><code>print(hexStr(15))  # Output: \"0f\"\n</code></pre>"},{"location":"reference/colors/#random_int","title":"<code>random_int</code>","text":"<pre><code>random_int(min_val: int, max_val: int) -&gt; int\n</code></pre> <p>Returns a random integer N such that min_val &lt;= N &lt;= max_val.</p> <p>Parameters</p> <ul> <li><code>min_val</code> (int): The minimum value.</li> <li><code>max_val</code> (int): The maximum value.</li> </ul> <pre><code>print(random_int(1, 10))  # Output: An integer between 1 and 10\n</code></pre>"},{"location":"reference/colors/#str2rgb","title":"<code>str2rgb</code>","text":"<pre><code>str2rgb(col: str) -&gt; dict\n</code></pre> <p>Converts a hex color string to an RGB dictionary. Accepts strings in the format \"#RRGGBB\" or \"#RGB\". If the input doesn't match, returns <code>{'r': 0, 'g': 0, 'b': 0}</code>.</p> <p>Parameters</p> <ul> <li><code>col</code> (str): A hex color string.</li> </ul> <pre><code>print(str2rgb(\"#ff0000\"))  # Output: {'r': 255, 'g': 0, 'b': 0}\nprint(str2rgb(\"#f00\"))     # Output: {'r': 255, 'g': 0, 'b': 0}\n</code></pre>"},{"location":"reference/colors/#hex_to_rgb","title":"<code>hex_to_rgb</code>","text":"<pre><code>hex_to_rgb(hex_color: str) -&gt; tuple[int, int, int]\n</code></pre> <p>Converts a hex color string (e.g., \"#ff0000\") to an (R, G, B) tuple.</p> <p>Parameters</p> <ul> <li><code>hex_color</code> (str): A hex color string in the format \"#RRGGBB\".</li> </ul> <pre><code>print(hex_to_rgb(\"#00ff00\"))  # Output: (0, 255, 0)\n</code></pre>"},{"location":"reference/colors/#rgb_to_hex","title":"<code>rgb_to_hex</code>","text":"<pre><code>rgb_to_hex(rgb: tuple[int, int, int]) -&gt; str\n</code></pre> <p>Converts an (R, G, B) tuple to a hex color string.</p> <p>Parameters</p> <ul> <li><code>rgb</code> (tuple[int, int, int]): A tuple representing red, green, and blue values.</li> </ul> <pre><code>print(rgb_to_hex((0, 0, 255)))  # Output: \"#0000ff\"\n</code></pre>"},{"location":"reference/colors/#color2rgba","title":"<code>color2rgba</code>","text":"<pre><code>color2rgba(c, alpha=1) -&gt; str\n</code></pre> <p>Converts an input color (which can be a list/tuple of three numbers, an integer, or a hex string) and an alpha value to an \"rgba(r, g, b, a)\" string.</p> <p>Parameters</p> <ul> <li><code>c</code> (list/tuple/int/str): The input color in one of the supported formats.</li> <li><code>alpha</code> (float, optional): The alpha value (default is 1).</li> </ul> <pre><code>print(color2rgba((255, 0, 0), 0.5))   # Output: \"rgba(255, 0, 0, 0.5)\"\nprint(color2rgba(\"#00ff00\", 0.75))     # Output: \"rgba(0, 255, 0, 0.75)\"\n</code></pre>"},{"location":"reference/colors/#blend","title":"<code>blend</code>","text":"<pre><code>blend(color1: str, color2: str, proportion: float) -&gt; str\n</code></pre> <p>Blends two hex color strings by the given proportion. A proportion of 0 returns color1 and 1 returns color2. Returns the blended color as a hex string.</p> <p>Parameters</p> <ul> <li><code>color1</code> (str): The first hex color string.</li> <li><code>color2</code> (str): The second hex color string.</li> <li><code>proportion</code> (float): The blend proportion (between 0 and 1).</li> </ul> <pre><code>print(blend(\"#ff0000\", \"#0000ff\", 0.5))  # Output: A blended color, e.g., \"#800080\"\n</code></pre>"},{"location":"reference/colors/#random_color","title":"<code>random_color</code>","text":"<pre><code>random_color() -&gt; str\n</code></pre> <p>Generates a random hex color string.</p> <pre><code>print(random_color())  # Output: e.g., \"#3a5fcd\"\n</code></pre>"},{"location":"reference/colors/#generate_colors","title":"<code>generate_colors</code>","text":"<pre><code>generate_colors(\n    base_color: str,\n    n: int = 10\n) -&gt; list[str]\n</code></pre> <p>Generates a list of colors equally distributed on the color wheel. The function uses the hue of the provided base color as a starting point and preserves its lightness and saturation, then rotates the hue in equal increments to produce a balanced palette of <code>n</code> colors.</p> <p>Parameters</p> <ul> <li><code>base_color</code> (str): The starting color in hex format (e.g., \"#db45f9\"). This color provides the lightness and saturation for the generated palette.</li> <li><code>n</code> (int): The total number of colors to generate.</li> </ul> <p>Returns</p> <ul> <li>(list[str]): A list of hex color strings representing the generated color palette.</li> </ul> <pre><code># Example: Generate an equally distributed palette of 10 colors.\npalette = generate_colors(base_color=\"#db45f9\", n=10)\nprint(palette)\n# Example output: ['#db45f9', '#c4f95d', '#6cf95d', '#5d9ef9', ...]\n</code></pre> <p>This function leverages color space conversions (RGB \u2194 HLS) to evenly distribute hues, ensuring that the generated colors are well balanced while maintaining the original color's lightness and saturation.</p>"},{"location":"reference/core/animate/","title":"<code>Animate</code>","text":"<p>The <code>Animate</code> class represents an SVG animation element. It allows you to animate an attribute by specifying repeat count and a sequence of values.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/animate/#pydreampletcoreanimate","title":"<code>pydreamplet.core.Animate</code>","text":"<pre><code>Animate(attr: str, **kwargs)\n</code></pre> <p>Initializes a new animation for the specified attribute.</p> <p>Parameters</p> <ul> <li><code>attr</code> (str): The SVG attribute to animate.</li> <li><code>**kwargs</code>: Additional attributes for the animate element.</li> </ul> <pre><code>from pydreamplet.core import Animate\nanim = Animate(\"fill\", from_=\"red\", to=\"blue\")\n</code></pre>"},{"location":"reference/core/animate/#repeat_count","title":"<code>repeat_count</code>","text":"<p>Getter: Returns the repeat count of the animation.</p> <p>Setter: Updates the repeat count and the corresponding attribute.</p> <pre><code>print(anim.repeat_count)\nanim.repeat_count = \"indefinite\"\n</code></pre>"},{"location":"reference/core/animate/#values","title":"<code>values</code>","text":"<p>Getter: Returns the list of animation values.</p> <p>Setter: Sets the list of values and updates the values attribute.</p> <pre><code>anim.values = [\"red\", \"green\", \"blue\"]\n</code></pre>"},{"location":"reference/core/circle/","title":"<code>Circle</code>","text":"<p>The <code>Circle</code> class represents an SVG circle element. It supports setting the center position and radius, and provides computed properties such as diameter and area.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/circle/#pydreampletcorecircle","title":"<code>pydreamplet.core.Circle</code>","text":"<pre><code>Circle(**kwargs)\n</code></pre> <p>Initializes a new circle. If pos is provided in kwargs, it sets the circle's center coordinates.</p> <p>Parameters</p> <ul> <li><code>**kwargs</code>: Attributes for the circle, including pos (a <code>Vector</code>) and other SVG properties (e.g., r for radius).</li> </ul> <pre><code>from pydreamplet import SVG, Circle\n\nsvg = SVG(200, 200)\nsvg.append(Circle(cx=100, cy=100, r=50, fill=\"#a00344\"))\n</code></pre> <p></p>"},{"location":"reference/core/circle/#pos","title":"<code>pos</code>","text":"<p>Getter: Returns the center of the circle as a <code>Vector</code>.</p> <p>Setter: Updates the center coordinates.</p> <pre><code>print(circle.pos)\ncircle.pos = Vector(60, 60)\n</code></pre>"},{"location":"reference/core/circle/#radius","title":"<code>radius</code>","text":"<p>Getter: Returns the radius of the circle.</p> <p>Setter: Updates the radius.</p> <pre><code>print(circle.radius)\ncircle.radius = 30\n</code></pre>"},{"location":"reference/core/circle/#center","title":"<code>center</code>","text":"<p>Alias for pos, returning the circle's center.</p>"},{"location":"reference/core/circle/#diameter","title":"<code>diameter</code>","text":"<p>Returns the circle's diameter (2 \u00d7 radius).</p>"},{"location":"reference/core/circle/#area","title":"<code>area</code>","text":"<p>Returns the area of the circle, computed as \\(\\pi \\times (\\text{radius})^2\\).</p>"},{"location":"reference/core/ellipse/","title":"<code>Ellipse</code>","text":"<p>The <code>Ellipse</code> class represents an SVG ellipse element. It supports setting the center position.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/ellipse/#pydreampletcoreellipse","title":"<code>pydreamplet.core.Ellipse</code>","text":"<pre><code>Ellipse(**kwargs)\n</code></pre> <p>Initializes a new ellipse. If <code>pos</code> is provided, it sets the center coordinates.</p> <p>Parameters</p> <ul> <li><code>**kwargs</code>: Attributes for the ellipse, including <code>pos</code> (a <code>Vector</code>) and other properties (e.g., <code>rx</code>, <code>ry</code>).</li> </ul> <pre><code>from pydreamplet import SVG, Ellipse, Vector\n\nsvg = SVG(200, 200)\nsvg.append(Ellipse(pos=Vector(100, 100), rx=60, ry=40, fill=\"#a00344\"))\n</code></pre> <p></p>"},{"location":"reference/core/ellipse/#pos","title":"<code>pos</code>","text":"<p>Getter: Returns the center of the ellipse as a <code>Vector</code>.</p> <p>Setter: Updates the center coordinates.</p> <pre><code>print(ellipse.pos)\nellipse.pos = Vector(120, 90)\n</code></pre>"},{"location":"reference/core/g/","title":"<code>G</code>","text":"<p>The <code>G</code> class represents a group (<code>&lt;g&gt;</code>) element in SVG. It inherits from both SvgElement and Transformable to allow grouped elements to be transformed together.</p> <p>Info</p> <p>This class inherits from <code>Transformable</code> and <code>SvgElement</code>.</p>"},{"location":"reference/core/g/#pydreampletcoreg","title":"<code>pydreamplet.core.G</code>","text":"<pre><code>G(\n    pos: Vector = None,\n    scale: Vector = None,\n    angle: float = 0,\n    pivot: Vector = None,\n    order: str = \"trs\",\n    **kwargs\n)\n</code></pre> <p>Initializes a group element with optional transformation properties and a pivot point.</p> <p>Parameters</p> <ul> <li><code>pos</code> (Vector, optional): Position vector (default: (0, 0)).</li> <li><code>scale</code> (Vector, optional): Scale vector (default: (1, 1)).</li> <li><code>angle</code> (float): Rotation angle (default: 0).</li> <li><code>pivot</code> (Vector, optional): Pivot point for rotation (default: (0, 0)).</li> <li><code>order</code> (str): Transformation order (combination of 't', 'r', 's'; default: \"trs\").</li> </ul> <pre><code>from pydreamplet.core import G\nfrom pydreamplet.math import Vector\ngroup = G(pos=Vector(10, 20), angle=30)\n</code></pre>"},{"location":"reference/core/g/#pivot","title":"<code>pivot</code>","text":"<p>Getter: Returns the pivot point as a Vector.</p> <p>Setter: Updates the pivot point and refreshes the transform.</p> <pre><code>print(group.pivot)\ngroup.pivot = Vector(5, 5)\n</code></pre>"},{"location":"reference/core/g/#order","title":"<code>order</code>","text":"<p>Getter: Returns the current transformation order.</p> <p>Setter: Updates the order and refreshes the transform.</p> <pre><code>print(group.order)\ngroup.order = \"rts\"\n</code></pre>"},{"location":"reference/core/g/#remove","title":"<code>remove</code>","text":"<pre><code>remove(self, child) -&gt; G\n</code></pre> <p>Removes a child element. If the group becomes empty, it removes itself from its parent.</p>"},{"location":"reference/core/g/#attrs","title":"<code>attrs</code>","text":"<pre><code>attrs(self, attributes: dict) -&gt; G\n</code></pre> <p>Sets multiple attributes on the group, including parsing transformation details.</p>"},{"location":"reference/core/g/#from_element","title":"<code>from_element</code>","text":"<pre><code>G.from_element(element: ET.Element)\n</code></pre> <p>Creates a G instance from an ElementTree element by parsing its transformation attributes.</p>"},{"location":"reference/core/line/","title":"<code>Line</code>","text":"<p>The <code>Line</code> class represents an SVG line element. It allows setting start and end coordinates and provides computed properties for its length and angle.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/line/#pydreampletcoreline","title":"<code>pydreamplet.core.Line</code>","text":"<pre><code>Line(\n    x1: float = 0,\n    y1: float = 0,\n    x2: float = 0,\n    y2: float = 0,\n    **kwargs\n)\n</code></pre> <p>Initializes a new line with specified start (x1, y1) and end (x2, y2) coordinates.</p> <p>Parameters</p> <ul> <li><code>x1</code> (float): The x-coordinate of the start point.</li> <li><code>y1</code> (float): The y-coordinate of the start point.</li> <li><code>x2</code> (float): The x-coordinate of the end point.</li> <li><code>y2</code> (float): The y-coordinate of the end point.</li> <li><code>**kwargs</code>: Additional attributes for the line.</li> </ul> <pre><code>from pydreamplet import SVG, Line\n\nsvg = SVG(200, 200)\nsvg.append(\n    Line(x1=10, y1=190, x2=190, y2=10, stroke=\"#a00344\", stroke_width=5)\n)\n</code></pre> <p></p>"},{"location":"reference/core/line/#x1-y1-x2-y2","title":"<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>","text":"<p>Getters and Setters: Retrieve or update the line's coordinates.</p> <pre><code>print(line.x1, line.y1, line.x2, line.y2)\nline.x1 = 10\nline.y1 = 10\n</code></pre>"},{"location":"reference/core/line/#length","title":"<code>length</code>","text":"<p>Returns the length of the line calculated using the distance formula.</p> <pre><code>print(line.length)\n</code></pre>"},{"location":"reference/core/line/#angle","title":"<code>angle</code>","text":"<p>Returns the angle (in degrees) of the line relative to the positive x-axis.</p> <pre><code>print(line.angle)\n</code></pre>"},{"location":"reference/core/path/","title":"<code>Path</code>","text":"<p>The <code>Path</code> class represents an SVG path element. It allows you to set the path data and provides computed properties based on the coordinates within the path.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/path/#pydreampletcorepath","title":"<code>pydreamplet.core.Path</code>","text":"<pre><code>Path(d: str = \"\", **kwargs)\n</code></pre> <p>Initializes a new path with an optional d attribute containing path commands.</p> <p>Parameters</p> <ul> <li><code>d</code> (str, optional): The path data string.</li> <li><code>**kwargs</code>: Additional attributes for the path element.</li> </ul> <pre><code>from pydreamplet import SVG, Path\nfrom pydreamplet.shapes import star\n\nsvg = SVG(200, 200)\nsvg.append(\n    Path(\n        d=star(svg.w / 2, svg.h / 2, inner_radius=30, outer_radius=80, angle=-18),\n        fill=\"#a00344\",\n    )\n)\n</code></pre> <p></p>"},{"location":"reference/core/path/#d","title":"<code>d</code>","text":"<p>Getter: Returns the path data string.</p> <p>Setter: Updates the path data.</p> <pre><code>print(path.d)\npath.d = \"M0 0 L50 50\"\n</code></pre>"},{"location":"reference/core/path/#w","title":"<code>w</code>","text":"<p>Returns the width of the path based on the extracted coordinates.</p>"},{"location":"reference/core/path/#h","title":"<code>h</code>","text":"<p>Returns the height of the path based on the extracted coordinates.</p>"},{"location":"reference/core/path/#center","title":"<code>center</code>","text":"<p>Returns the center point of the path as a <code>Vector</code>.</p>"},{"location":"reference/core/polygon/","title":"<code>Polygon</code>","text":"<p>The <code>Polygon</code> class represents an SVG polygon element. It allows setting a list of points and automatically formats these into the SVG-compatible <code>\"x,y x,y \u2026\"</code> string.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/polygon/#pydreampletcorepolygon","title":"<code>pydreamplet.core.Polygon</code>","text":"<pre><code>Polygon(\n    points: list[Real],\n    **kwargs\n)\n</code></pre> <p>Initializes a new polygon with the specified vertices. The points must be provided as a list of numbers where every two elements represent the x and y coordinates of a vertex.</p> <p>Parameters</p> <ul> <li><code>points</code> (list[Real]): A list of numbers representing the polygon's vertices, for example: <code>[x1, y1, x2, y2, x3, y3, ...]</code>.</li> <li><code>**kwargs</code>: Additional attributes for the polygon element.</li> </ul> <pre><code>from pydreamplet import SVG, Polygon\n\nsvg = SVG(200, 200)\nsvg.append(Polygon([10, 10, 100, 180, 150, 50], fill=\"#a00344\"))\n</code></pre> <p></p>"},{"location":"reference/core/polygon/#points","title":"<code>points</code>","text":"<p>Getters and Setters: Retrieve or update the polygon's points. When setting new points, the list is automatically formatted into a string where each vertex is expressed as <code>\"x,y\"</code> and each pair is separated by a space.</p> <pre><code>print(polygon.points)  # [0, 0, 50, 50, 100, 0]\npolygon.points = [0, 0, 0, 20, 20, 20, 20, 0]\n</code></pre> <p>When the <code>points</code> setter is called, the underlying SVG element's <code>points</code> attribute is updated to: <code>points=\"0,0 0,20 20,20 20,0\"</code>.</p>"},{"location":"reference/core/polyline/","title":"<code>Polyline</code>","text":"<p>The <code>Polyline</code> class represents an SVG polyline element. It allows setting a list of points and automatically formats these into the SVG-compatible <code>\"x,y x,y \u2026\"</code> string.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/polyline/#pydreampletcorepolyline","title":"<code>pydreamplet.core.Polyline</code>","text":"<pre><code>Polyline(\n    points: list[Real],\n    **kwargs\n)\n</code></pre> <p>Initializes a new polyline with the specified vertices. The points must be provided as a list of numbers where every two elements represent the x and y coordinates of a vertex.</p> <p>Parameters</p> <ul> <li><code>points</code> (list[Real]): A list of numbers representing the polyline's vertices, for example: <code>[x1, y1, x2, y2, x3, y3, ...]</code>.</li> <li><code>**kwargs</code>: Additional attributes for the polyline element.</li> </ul> <pre><code>from pydreamplet import SVG, Polyline\n\nsvg = SVG(200, 200)\nsvg.append(\n    Polyline([10, 10, 100, 180, 150, 50], stroke=\"#a00344\", fill=\"none\", stroke_width=5)\n)\n</code></pre> <p></p>"},{"location":"reference/core/polyline/#points","title":"<code>points</code>","text":"<p>Getters and Setters: Retrieve or update the polyline's points. When setting new points, the list is automatically formatted into a string where each vertex is expressed as <code>\"x,y\"</code> and each pair is separated by a space.</p> <pre><code>print(polyline.points)  # [0, 0, 50, 50, 100, 0]\npolyline.points = [0, 0, 0, 20, 20, 20, 20, 0]\n</code></pre> <p>When the <code>points</code> setter is called, the underlying SVG element's <code>points</code> attribute is updated to: <code>points=\"0,0 0,20 20,20 20,0\"</code>.</p>"},{"location":"reference/core/rect/","title":"<code>Rect</code>","text":"<p>The <code>Rect</code> class represents an SVG rectangle element. It supports setting the position and provides properties for width and height.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/rect/#pydreampletcorerect","title":"<code>pydreamplet.core.Rect</code>","text":"<pre><code>Rect(**kwargs)\n</code></pre> <p>Initializes a new rectangle. If pos is provided, it sets the top-left corner.</p> <p>Parameters</p> <ul> <li><code>**kwargs</code>: Attributes for the rectangle, including <code>pos</code> (a <code>Vector</code>) and other properties (e.g., <code>width</code>, <code>height</code>).</li> </ul> <pre><code>from pydreamplet import SVG, Rect, Vector\n\nsvg = SVG(200, 200)\nsvg.append(\n    Rect(\n        pos=Vector(50, 50),\n        width=100,\n        height=100,\n        fill=\"#a00344\",\n    )\n)\n</code></pre> <p></p>"},{"location":"reference/core/rect/#pos","title":"<code>pos</code>","text":"<p>Getter: Returns the position (top-left corner) as a <code>Vector</code>.</p> <p>Setter: Updates the position.</p> <pre><code>print(rect.pos)\nrect.pos = Vector(20, 20)\n</code></pre>"},{"location":"reference/core/rect/#width","title":"<code>width</code>","text":"<p>Returns the width of the rectangle.</p>"},{"location":"reference/core/rect/#height","title":"<code>height</code>","text":"<p>Returns the height of the rectangle.</p>"},{"location":"reference/core/svg/","title":"<code>SVG</code>","text":"<p>The <code>SVG</code> class represents the root SVG element. It manages the viewbox, provides properties for dimensions, and includes methods for displaying and saving the SVG.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/svg/#pydreampletcoresvg","title":"<code>pydreamplet.core.SVG</code>","text":"<pre><code>SVG(*viewbox, **kwargs)\n</code></pre> <p>Initializes a new SVG element with the specified viewbox. The viewbox can be provided as a tuple of 2 (width, height) or 4 (min-x, min-y, width, height) numbers.</p> <p>Parameters</p> <ul> <li><code>viewbox</code> (tuple or list): Dimensions for the SVG.</li> <li><code>**kwargs</code>: Additional attributes for the SVG element.</li> </ul> <pre><code>svg = SVG(800, 600)\nprint(svg)  # &lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 800 600\" width=\"800px\" height=\"600px\" /&gt;\n</code></pre> <p>You can change the default values of width and height passing <code>**kwargs</code>.</p> <pre><code>svg = SVG(800, 600, width=\"400px\", height=\"300px\")\nprint(svg)  # &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400px\" height=\"300px\" viewBox=\"0 0 800 600\" /&gt;\n</code></pre> <p>It does not need to be done during initialization. You can set any attribute of SvgElement using <code>**kwargs</code>.</p> <pre><code>svg = dp.SVG(300, 300)\nsvg.width = \"600px\"\nsvg.height = \"600px\"\n</code></pre>"},{"location":"reference/core/svg/#from_element","title":"<code>from_element</code>","text":"<pre><code>SVG.from_element(element: ET.Element)\n</code></pre> <p>Creates an SVG instance from an ElementTree element.</p>"},{"location":"reference/core/svg/#from_file","title":"<code>from_file</code>","text":"<pre><code>SVG.from_file(filename: str)\n</code></pre> Usage example<pre><code>from importlib.resources import files\nfrom pydreamplet import SVG, resources\n\nsvg = SVG.from_file(files(resources) / \"hummingbird.svg\").attrs(\n    {\"width\": 96, \"height\": 84}\n)\nsvg.find(\"path\").fill = \"darkgreen\"\n</code></pre> <p>Creates an SVG instance by parsing an SVG file.</p>"},{"location":"reference/core/svg/#w-and-h","title":"<code>w</code> and <code>h</code>","text":"<p>Getter: Returns the width (w) and height (h) of the SVG based on its <code>viewBox</code>.</p> <p>Warning</p> <p>Remember, based on <code>viewBox</code>. Do not confuse these properties with <code>width</code> and <code>height</code> attributes of the SVG element.</p> <pre><code>import pydreamplet as dp\n\nsvg = dp.SVG(300, 300)\nsvg.width = \"600px\"\nsvg.height = \"600px\"\nprint(f\"svg viewBox is {svg.viewBox}\")  # Outputs svg viewBox is 0 0 300 300\nprint(f\"svg.w is {svg.w}, svg.h is {svg.h}\")  # Outputs svg.w is 300, svg.h is 300\nprint(f\"svg.width is {svg.width}, svg.height is {svg.height}\")  # Outputs svg.width is 600px, svg.height is 600px\n</code></pre>"},{"location":"reference/core/svg/#style","title":"<code>style</code>","text":"<pre><code>def style(\n    self, file_path: str, overwrite: bool = True, minify: bool = True\n) -&gt; None\n</code></pre> <p>Adds a <code>&lt;style&gt;</code> element to the SVG using CSS content loaded from an external file. When <code>overwrite</code> is set to <code>True</code>, any existing <code>&lt;style&gt;</code> elements are removed and the new one is inserted as the first child. When <code>minify</code> is <code>True</code>, the CSS content is minified before insertion.</p> Usage examplemy_style.css <p> <pre><code>from pydreamplet import SVG, Circle\n\nsvg = SVG(200, 200)\nsvg.append(Circle(cx=100, cy=100, r=50))\n\nsvg.style(\"my_style.css\")\n</code></pre></p> <pre><code>circle {\n  fill: rgb(160, 3, 68);\n  stroke: #000;\n  stroke-width: 20px;\n}\n</code></pre> <p></p>"},{"location":"reference/core/svg/#display","title":"<code>display</code>","text":"<pre><code>display(self) -&gt; None\n</code></pre> <p>Displays the SVG in an IPython environment.</p>"},{"location":"reference/core/svg/#save","title":"<code>save</code>","text":"<pre><code>save(self, filename: str) -&gt; None\n</code></pre> <p>Saves the SVG to a file.</p>"},{"location":"reference/core/svgelement/","title":"<code>SvgElement</code>","text":"<p>The <code>SvgElement</code> class serves as the base for all SVG elements. It wraps an ElementTree element, provides a registry for specialized classes, and offers methods for managing attributes, children, and searching within the SVG tree.</p>"},{"location":"reference/core/svgelement/#pydreampletcoresvg","title":"<code>pydreamplet.core.SVG</code>","text":"<pre><code>SvgElement (self, tag, **kwargs)\n</code></pre> <p>Initializes a new SVG element with the specified tag and attributes.</p> <p>Parameters</p> <ul> <li><code>tag</code> (str): The SVG tag name.</li> <li><code>**kwargs</code>: Additional attributes for the element.</li> </ul> <pre><code>elem = SvgElement(\"rect\", fill=\"red\")\nprint(elem)  # Outputs the XML representation of the element.\n</code></pre>"},{"location":"reference/core/svgelement/#register","title":"<code>register</code>","text":"<pre><code>SvgElement.register(tag: str, subclass: type) -&gt; None\n</code></pre> <p>Registers a specialized subclass for a given SVG tag. This is needed only for registration the SVG element classes, created by the user. Probably you will not need to us it.</p>"},{"location":"reference/core/svgelement/#from_element","title":"<code>from_element</code>","text":"<pre><code>SvgElement.from_element(element: ET.Element)\n</code></pre> <p>Creates an instance from an ElementTree element, using the registered subclass if available.</p> <pre><code>import xml.etree.ElementTree as ET\nelem = ET.Element(\"rect\")\nsvg_elem = SvgElement.from_element(elem)\n</code></pre>"},{"location":"reference/core/svgelement/#attrs","title":"<code>attrs</code>","text":"<pre><code>attrs(self, attributes: dict) -&gt; SvgElement\n</code></pre> <p>Sets multiple attributes on the element.</p> <pre><code>drop_shadow = SvgElement(\"feDropShadow\")\ndrop_shadow.attrs({\n    \"id\": \"shadow\",\n    \"dx\": \"0.2\",\n    \"dy\": \"0.4\",\n    \"stdDeviation\": \"0.2\",\n})\nprint(drop_shadow)  # &lt;feDropShadow xmlns=\"http://www.w3.org/2000/svg\" id=\"shadow\" dx=\"0.2\" dy=\"0.4\" stdDeviation=\"0.2\" /&gt;\n</code></pre>"},{"location":"reference/core/svgelement/#has_attr","title":"<code>has_attr</code>","text":"<pre><code>has_attr(self, name: str) -&gt; bool\n</code></pre> <p>Checks if the element has the specified attribute. Attribute names with underscores are automatically converted to hyphens (e.g., <code>font_size</code> becomes <code>font-size</code>). The special attribute name <code>class_name</code> is mapped to the SVG <code>class</code> attribute.</p> <p>Parameters</p> <ul> <li><code>name</code> (str): The attribute name to check for.</li> </ul> <p>Returns</p> <ul> <li><code>bool</code>: <code>True</code> if the attribute exists, <code>False</code> otherwise.</li> </ul> <pre><code>rect = SvgElement(\"rect\", fill=\"red\", stroke_width=\"2\")\nprint(rect.has_attr(\"fill\"))         # True\nprint(rect.has_attr(\"stroke_width\")) # True (checks for \"stroke-width\")\nprint(rect.has_attr(\"opacity\"))      # False\n\n# Special case for class attribute\ntext = SvgElement(\"text\", class_name=\"highlight\")\nprint(text.has_attr(\"class_name\"))   # True\n</code></pre>"},{"location":"reference/core/svgelement/#append","title":"<code>append</code>","text":"<pre><code>append(self, *children) -&gt; SvgElement\n</code></pre> <p>Appends aone or more child elements to the current element. Returns self, allowing method chaining.</p>"},{"location":"reference/core/svgelement/#remove","title":"<code>remove</code>","text":"<pre><code>remove(self, *children) -&gt; SvgElement\n</code></pre> <p>Removes one or more child elements from the current element. If a child was wrapped, it removes its underlying element.</p> <pre><code>svg = SVG(800, 600, width=\"400px\", height=\"300px\")\ng1 = G()\ng2 = G()\nsvg.append(g1, g2)\ng1.append(Circle())\ng2.append(Rect())\n\nprint(svg)\n# &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400px\" height=\"300px\" viewBox=\"0 0 800 600\"&gt;&lt;g&gt;&lt;circle /&gt;&lt;/g&gt;&lt;g&gt;&lt;rect /&gt;&lt;/g&gt;&lt;/svg&gt;\n\nsvg.remove(g1)\nprint(svg)\n# &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400px\" height=\"300px\" viewBox=\"0 0 800 600\"&gt;&lt;g&gt;&lt;rect /&gt;&lt;/g&gt;&lt;/svg&gt;\n</code></pre>"},{"location":"reference/core/svgelement/#to_string","title":"<code>to_string</code>","text":"<pre><code>to_string(self, pretty_print: bool = True) -&gt; str\n</code></pre> <p>Returns the SVG element as a string. If pretty_print is set to <code>True</code>, the output is formatted with indentation for improved readability (using Python\u2019s built-in <code>ET.indent</code> available from Python 3.9 onward).</p>"},{"location":"reference/core/svgelement/#find-and-find_all","title":"<code>find</code> and <code>find_all</code>","text":"<pre><code>find(self, tag: str, nested: bool = False, id: str | None = None)\nfind_all(self, tag: str, nested: bool = False, class_name: str | None = None)\n</code></pre> <p>Searches for child elements by tag. If <code>nested</code> is <code>True</code>, the search is recursive.</p> <p>For <code>find</code>, if an <code>id</code> is provided, only the element with that matching id will be returned. For <code>find_all</code>, if a <code>class_name</code> is provided, only elements with that matching class attribute will be returned.</p>"},{"location":"reference/core/svgelement/#copy","title":"<code>copy</code>","text":"<pre><code>copy(self) -&gt; SvgElement\n</code></pre> <p>Creates and returns a deep copy of the current SVG element. The new instance is a complete duplicate with its own separate copy of the underlying ElementTree element (and its subtree). This ensures that subsequent modifications to the copy do not affect the original element.</p> <p>For example:</p> <pre><code>original = SvgElement(\"rect\", x=10, y=20, width=100, height=50)\nduplicate = original.copy()\nduplicate.x = 30  # This change will not affect the original element.\n</code></pre> <p>Using <code>copy()</code> is especially useful when you need to duplicate elements and then modify them independently in your SVG structure.</p>"},{"location":"reference/core/text/","title":"<code>Text</code>","text":"<p>The <code>Text</code> class represents an SVG text element. It supports setting the position and content, and for multiline text, it automatically splits the content into  elements. <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/text/#pydreampletcoretext","title":"<code>pydreamplet.core.Text</code>","text":"<pre><code>Text(initial_text: str = \"\", **kwargs)\n</code></pre> <p>Initializes a new text element with optional initial content. If pos is provided, it sets the text position.</p> <p>Parameters</p> <ul> <li><code>initial_text</code> (str, optional): The initial text content.</li> <li><code>**kwargs</code>: Additional attributes for the text element. Common keyword arguments include:<ul> <li><code>pos</code> (Vector): Specifies the text position.</li> <li><code>v_space</code> (number, optional): Controls the vertical space between lines for multiline text.</li> <li><code>font_size</code> (str, optional): Specifies the font size. The provided value should include a unit (e.g. <code>\"10.5pt\"</code>, <code>\"18px\"</code>, etc.). If no unit is provided, <code>\"px\"</code> is appended by default. The getter returns only the numeric portion as a float.</li> </ul> </li> </ul> <pre><code>from pydreamplet import SVG, Text, Vector\n\nsvg = SVG(300, 200).append(\n    Text(\n        \"Hello,\\nWorld!\",\n        pos=Vector(60, 80),\n        v_space=84,\n        font_size=64,\n        fill=\"#1b313b\"\n    )\n)\n</code></pre> <p></p>"},{"location":"reference/core/text/#pos","title":"<code>pos</code>","text":"<p>Getter: Returns the text position as a <code>Vector</code>.</p> <p>Setter: Updates the text position.</p> <pre><code>print(text_elem.pos)\ntext_elem.pos = Vector(60, 60)\n</code></pre>"},{"location":"reference/core/text/#content","title":"<code>content</code>","text":"<p>Getter: Returns the raw text content.</p> <p>Setter: Updates the text content. For multiline text, the content is split into  elements. <pre><code>print(text_elem.content)\ntext_elem.content = \"Line 1\\nLine 2\"\n</code></pre>"},{"location":"reference/core/textonpath/","title":"<code>TextOnPath</code>","text":"<p>The TextOnPath class represents an SVG text element that follows a path. It wraps a  element to render text along a specified path. <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/core/textonpath/#pydreampletcoretextonpath","title":"<code>pydreamplet.core.TextOnPath</code>","text":"<pre><code>TextOnPath(\n    initial_text: str = \"\",\n    path: str = \"\",\n    text_path_args: dict = None, \n    **kwargs\n)\n</code></pre> <p>Initializes a new text-on-path element with optional initial content and a reference to a path.</p> <p>Parameters</p> <ul> <li><code>initial_text</code> (str, optional): The initial text content.</li> <li><code>path</code> (str, optional): The path identifier (e.g., an href value) to bind the text to.</li> <li><code>text_path_args</code> (dict, optional): Additional attributes for the <code>&lt;textPath&gt;</code> element.</li> <li><code>**kwargs</code>: Additional attributes for the text element.</li> </ul> <pre><code>from pydreamplet import TextOnPath\n\ntext_on_path = TextOnPath(\"Curved Text\", path=\"#myPath\", fill=\"blue\")\n</code></pre>"},{"location":"reference/core/textonpath/#content","title":"<code>content</code>","text":"<p><code>Getter:</code> Returns the text content rendered on the path.</p> <p><code>Setter:</code> Updates the text content on the path.</p> <pre><code>print(text_on_path.content)\ntext_on_path.content = \"Updated Text\"\n</code></pre> Usage example<pre><code>import pydreamplet as dp\n\nsvg = dp.SVG(100, 100)\nsvg.width = \"600px\"\nsvg.height = \"600px\"\n\npath = dp.Path(\n    id=\"my-path\",\n    d=\"M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50\",\n    fill=\"none\", \n    stroke=\"#3e685e\"\n)\n\ntext = dp.TextOnPath(\n    \"Lorem ipsum dolor sit amet.\",\n    path_id=\"#my-path\",\n    text_path_args={\"startOffset\": \"20%\"},\n)\nsvg.append(path).append(text)\nsvg.display()\n</code></pre> <p></p>"},{"location":"reference/core/transformable/","title":"<code>Transformable</code>","text":"<p>The Transformable mixin adds transformation capabilities\u2014translation, rotation, and scaling\u2014to SVG elements. It is intended for use with group elements.</p>"},{"location":"reference/core/transformable/#pydreampletcoretransformable","title":"<code>pydreamplet.core.Transformable</code>","text":"<pre><code>Transformable(\n    pos: Vector = None,\n    scale: Vector = None,\n    angle: float = 0,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Initializes transformation properties with position, scale, and rotation angle.</p> <p>Parameters</p> <ul> <li><code>pos</code> (Vector, optional): Position vector (default: (0, 0)).</li> <li><code>scale</code> (Vector, optional): Scale vector (default: (1, 1)).</li> <li><code>angle</code> (float): Rotation angle (default: 0).</li> </ul> <pre><code>t = Transformable(pos=Vector(10, 20), scale=Vector(2, 2), angle=45)\n</code></pre>"},{"location":"reference/core/transformable/#pos","title":"<code>pos</code>","text":"<p>Getter: Returns the current position as a Vector.</p> <p>Setter: Updates the position and refreshes the transform.</p> <pre><code>print(t.pos)\nt.pos = Vector(30, 40)\n</code></pre>"},{"location":"reference/core/transformable/#scale","title":"<code>scale</code>","text":"<p>Getter: Returns the current scale as a Vector.</p> <p>Setter: Updates the scale and refreshes the transform.</p> <pre><code>print(t.scale)\nt.scale = Vector(1, 1)\n</code></pre>"},{"location":"reference/core/transformable/#angle","title":"<code>angle</code>","text":"<p>Getter: Returns the current rotation angle.</p> <p>Setter: Updates the angle and refreshes the transform.</p> <pre><code>print(t.angle)\nt.angle = 90\n</code></pre>"},{"location":"reference/core/types/","title":"Type Definitions","text":"<p>This page documents the custom type definitions used throughout the pydreamplet library.</p>"},{"location":"reference/core/types/#core-types","title":"Core Types","text":""},{"location":"reference/core/types/#real","title":"<code>Real</code>","text":"<p>Defined in <code>pydreamplet.core</code>:</p> <pre><code>type Real = int | float\n</code></pre> <p>The <code>Real</code> type represents numeric values that can be either integers or floating-point numbers. This type is used extensively throughout the library for coordinates, dimensions, angles, and other numeric parameters.</p> <p>Usage Examples:</p> <pre><code>from pydreamplet.core import Real\n\n# These are all valid Real values\nx: Real = 10      # integer\ny: Real = 20.5    # float\nangle: Real = 45  # integer for angle\n</code></pre> <p>Used in: - Vector coordinates (<code>Vector(x: Real, y: Real)</code>) - SVG element dimensions and positions - Mathematical operations and transformations - Scale domains and ranges</p>"},{"location":"reference/core/types/#import-usage","title":"Import Usage","text":"<p>The <code>Real</code> type can be imported and used in your own code:</p> <pre><code>from pydreamplet.core import Real\n\ndef my_function(value: Real) -&gt; Real:\n    return value * 2\n</code></pre> <p>This provides consistent typing across your application when working with pydreamplet objects and functions.</p>"},{"location":"reference/markers/marker/","title":"<code>Marker</code>","text":"<p>The <code>Marker</code> class represents an SVG marker element used to define reusable graphics for lines and paths, such as arrows or custom symbols.</p> <p>Info</p> <p>This class inherits from <code>SvgElement</code>.</p>"},{"location":"reference/markers/marker/#dreampletmarkersmarker","title":"<code>dreamplet.markers.Marker</code>","text":"<pre><code>Marker(id: str, d: str, width: Real, height: Real, **kwargs)\n</code></pre> <p>Initializes a new marker. The marker is defined by a path string <code>d</code> and dimensions <code>width</code> and <code>height</code>. It creates an SVG <code>&lt;marker&gt;</code> element with a default viewBox of <code>\"0 0 10 10\"</code> and preconfigured attributes. Additional attributes\u2014such as refX, refY, and orient\u2014can be specified via kwargs to customize the marker\u2019s positioning and orientation. A nested <code>Path</code> element is automatically created with its own default style attributes.</p> <p>Parameters</p> <ul> <li><code>id</code> (str): A unique identifier for the marker.</li> <li><code>d</code> (str): A string representing the SVG path data that defines the shape of the marker. There are predefined markers you can use, or you can create your own.</li> <li><code>width</code> (Real): The width of the marker viewport.</li> <li><code>height</code> (Real): The height of the marker viewport.</li> <li><code>**kwargs</code>: Additional attributes for the marker element. Supported overrides include:<ul> <li><code>refX</code>: The x-coordinate for the marker\u2019s reference point (default: <code>\"5\"</code>).</li> <li><code>refY</code>: The y-coordinate for the marker\u2019s reference point (default: <code>\"5\"</code>).</li> <li><code>orient</code>: The orientation of the marker (default: <code>\"0\"</code>).</li> <li><code>fill</code>: Fill color for the marker\u2019s path (default: <code>\"#000000\"</code>).</li> <li><code>stroke</code>: Stroke color for the marker\u2019s path (default: <code>\"none\"</code>).</li> <li><code>stroke-width</code>: Stroke width for the marker\u2019s path (default: <code>\"1\"</code>).</li> </ul> </li> </ul> <pre><code>from pydreamplet import SVG, SvgElement, Polyline\nfrom pydreamplet.markers import Marker, ARROW\n\nsvg = SVG(400, 150)\n\nsvg.append(SvgElement(\"defs\"))\n\nmarker = Marker(\n    \"arrow-head\", ARROW, 16, 16, fill=\"magenta\", orient=\"auto-start-reverse\"\n)\nsvg.find(\"defs\").append(marker)\n\npolyline = Polyline(\n    [50, 50, 100, 100, 150, 50, 200, 100, 250, 50, 300, 100, 350, 100],\n    stroke=\"#000\",\n    fill=\"none\",\n)\npolyline.marker_end = marker.id_ref\npolyline.marker_start = marker.id_ref\nsvg.append(polyline)\n</code></pre> <p></p>"},{"location":"reference/markers/marker/#d","title":"<code>d</code>","text":"<p>Getter: Returns the SVG path data string of the marker.</p> <p>Setter: Updates the marker's path data and reflects the change in the underlying path element.</p> <pre><code>print(marker.d)\nmarker.d = ARROW_CONVEX  # Update to a different arrow style\n</code></pre>"},{"location":"reference/markers/marker/#fill","title":"<code>fill</code>","text":"<p>Getter: Retrieves the fill color of the marker's path.</p> <p>Setter: Sets the fill color for the marker's path.</p> <pre><code>print(marker.fill)\nmarker.fill = \"#ff0000\"\n</code></pre>"},{"location":"reference/markers/marker/#stroke","title":"<code>stroke</code>","text":"<p>Getter: Returns the stroke color of the marker's path.</p> <p>Setter: Updates the stroke color of the marker's path.</p> <pre><code>print(marker.stroke)\nmarker.stroke = \"#00ff00\"\n</code></pre>"},{"location":"reference/markers/marker/#stroke_width","title":"<code>stroke_width</code>","text":"<p>Getter: Retrieves the stroke width of the marker's path.</p> <p>Setter: Sets the stroke width for the marker's path.</p> <pre><code>print(marker.stroke_width)\nmarker.stroke_width = 2\n</code></pre>"},{"location":"reference/markers/marker/#id_ref","title":"<code>id_ref</code>","text":"<p>Getter: Returns a URL reference string for the marker (e.g., <code>\"url(#arrow)\"</code>), which can be used to reference the marker within other SVG elements.</p>"},{"location":"reference/markers/predefined_markers/","title":"Predefined Markers","text":""},{"location":"reference/markers/predefined_markers/#arrow","title":"<code>ARROW</code>","text":""},{"location":"reference/markers/predefined_markers/#arrow_basic","title":"<code>ARROW_BASIC</code>","text":""},{"location":"reference/markers/predefined_markers/#arrow_concave","title":"<code>ARROW_CONCAVE</code>","text":""},{"location":"reference/markers/predefined_markers/#arrow_convex","title":"<code>ARROW_CONVEX</code>","text":""},{"location":"reference/markers/predefined_markers/#arrow_simple","title":"<code>ARROW_SIMPLE</code>","text":""},{"location":"reference/markers/predefined_markers/#cross","title":"<code>CROSS</code>","text":""},{"location":"reference/markers/predefined_markers/#diamond","title":"<code>DIAMOND</code>","text":""},{"location":"reference/markers/predefined_markers/#dot","title":"<code>DOT</code>","text":""},{"location":"reference/markers/predefined_markers/#square","title":"<code>SQUARE</code>","text":""},{"location":"reference/markers/predefined_markers/#tick_top","title":"<code>TICK_TOP</code>","text":""},{"location":"reference/markers/predefined_markers/#tick_bottom","title":"<code>TICK_BOTTOM</code>","text":""},{"location":"reference/markers/predefined_markers/#tick_left","title":"<code>TICK_LEFT</code>","text":""},{"location":"reference/markers/predefined_markers/#tick_right","title":"<code>TICK_RIGHT</code>","text":""},{"location":"reference/markers/predefined_markers/#tick_horizontal","title":"<code>TICK_HORIZONTAL</code>","text":""},{"location":"reference/markers/predefined_markers/#tick_vertical","title":"<code>TICK_VERTICAL</code>","text":""},{"location":"reference/math/vector/","title":"<code>Vector</code>","text":"<p>The <code>Vector</code> class provides a simple implementation of a two-dimensional vector. It supports common operations such as addition, subtraction, scalar multiplication and division, normalization, and more. The class makes use of Python\u2019s operator overloading to enable intuitive arithmetic with vectors, and it also offers properties for accessing and modifying the vector\u2019s components, magnitude, and direction.</p>"},{"location":"reference/math/vector/#dreampletmathvector","title":"<code>dreamplet.math.Vector</code>","text":"<pre><code>Vector(self, x: float, y: float)\n</code></pre> <p>Initializes a new 2D vector with the given x and y coordinates.</p> <p>Parameters</p> <ul> <li><code>x</code> (float): The x-coordinate.</li> <li><code>y</code> (float): The y-coordinate.</li> </ul> <pre><code>v = Vector(3.0, 4.0)\nprint(v)  # Output: Vector(x=3.0, y=4.0)\n</code></pre>"},{"location":"reference/math/vector/#set","title":"<code>set</code>","text":"<pre><code>set(self, x: float, y: float) -&gt; None\n</code></pre> <p>Updates the x and y coordinates of the vector.</p> <pre><code>v = Vector(1.0, 2.0)\nv.set(5.0, 6.0)\nprint(v.xy)  # Output: (5.0, 6.0)\n</code></pre>"},{"location":"reference/math/vector/#copy","title":"<code>copy</code>","text":"<pre><code>copy(self) -&gt; Vector\n</code></pre> <p>Returns a duplicate of the vector.</p> <pre><code>v1 = Vector(2.0, 3.0)\nv2 = v1.copy()\nprint(v1 == v2)  # Output: True\n</code></pre>"},{"location":"reference/math/vector/#dot","title":"<code>dot</code>","text":"<pre><code>dot(self, other: \"Vector\") -&gt; float\n</code></pre> <p>Calculates the dot product of the current vector with another vector.</p> <pre><code>v1 = Vector(1.0, 2.0)\nv2 = Vector(3.0, 4.0)\nresult = v1.dot(v2)\nprint(result)  # Output: 11.0 (1*3 + 2*4)\n</code></pre>"},{"location":"reference/math/vector/#normalize","title":"<code>normalize</code>","text":"<pre><code>normalize(self) -&gt; Vector\n</code></pre> <p>Returns a new vector that is the normalized version of the current vector (i.e., with a magnitude of 1). Raises a ValueError if the vector is zero.</p> <pre><code>v = Vector(3.0, 4.0)\nnormalized_v = v.normalize()\nprint(normalized_v.magnitude)  # Output: 1.0\n</code></pre>"},{"location":"reference/math/vector/#limit","title":"<code>limit</code>","text":"<pre><code>limit(self, limit_scalar: float) -&gt; None\n</code></pre> <p>Limits the magnitude of the vector to <code>limit_scalar</code>. If the current magnitude exceeds the limit, the vector is scaled down to the specified maximum.</p> <pre><code>v = Vector(10.0, 0.0)\nv.limit(5.0)\nprint(v.magnitude)  # Output: 5.0\n</code></pre>"},{"location":"reference/math/vector/#x-and-y","title":"<code>x</code> and <code>y</code>","text":"<p>Get or set the individual x and y components of the vector.</p> <pre><code>v = Vector(1.0, 2.0)\nprint(v.x, v.y)  # Output: 1.0 2.0\nv.x = 10.0\nv.y = 20.0\nprint(v.xy)  # Output: (10.0, 20.0)\n</code></pre>"},{"location":"reference/math/vector/#xy","title":"<code>xy</code>","text":"<p>Returns a tuple containing the x and y coordinates of the vector.</p> <pre><code>v = Vector(5.0, 6.0)\nprint(v.xy)  # Output: (5.0, 6.0)\n</code></pre>"},{"location":"reference/math/vector/#direction","title":"<code>direction</code>","text":"<p>Getter: Returns the angle (in degrees) of the vector relative to the positive x-axis, calculated using <code>atan2</code>.</p> <pre><code>v = Vector(1.0, 1.0)\nprint(v.direction)  # Output: ~45.0 (approximately 45 degrees)\n</code></pre> <p>Setter: Sets the vector\u2019s direction (angle in degrees) while preserving its magnitude.</p> <pre><code>v = Vector(3.0, 4.0)\nv.direction = 90  # Set direction to 90 degrees\nprint(v)  # Output: Vector(x\u22480.0, y=5.0)\n</code></pre>"},{"location":"reference/math/vector/#magnitude","title":"<code>magnitude</code>","text":"<p>Getter: Returns the length of the vector.</p> <pre><code>v = Vector(3.0, 4.0)\nprint(v.magnitude)  # Output: 5.0\n</code></pre> <p>Setter: Sets the vector\u2019s magnitude while preserving its direction.</p> <pre><code>v = Vector(3.0, 4.0)\nv.magnitude = 10.0\nprint(v.magnitude)  # Output: 10.0\n</code></pre>"},{"location":"reference/math/vector/#operations","title":"Operations","text":""},{"location":"reference/math/vector/#addition","title":"Addition","text":"<pre><code>v1 = Vector(1.0, 2.0)\nv2 = Vector(3.0, 4.0)\nv3 = v1 + v2\nprint(v3)  # Output: Vector(x=4.0, y=6.0)\n</code></pre>"},{"location":"reference/math/vector/#subtraction","title":"Subtraction","text":"<pre><code>v1 = Vector(5.0, 7.0)\nv2 = Vector(2.0, 3.0)\nv3 = v1 - v2\nprint(v3)  # Output: Vector(x=3.0, y=4.0)\n</code></pre>"},{"location":"reference/math/vector/#scalar-multiplication","title":"Scalar Multiplication","text":"<pre><code>v = Vector(2.0, 3.0)\nv_scaled = v * 3\nprint(v_scaled)  # Output: Vector(x=6.0, y=9.0)\n</code></pre>"},{"location":"reference/math/vector/#scalar-division","title":"Scalar Division","text":"<pre><code>v = Vector(6.0, 9.0)\nv_divided = v / 3\nprint(v_divided)  # Output: Vector(x=2.0, y=3.0)\n</code></pre>"},{"location":"reference/math/vector/#comparison","title":"Comparison","text":"<pre><code>v1 = Vector(1.0, 2.0)\nv2 = Vector(1.0, 2.0)\nprint(v1 == v2)  # Output: True\n</code></pre>"},{"location":"reference/noise/noise/","title":"<code>Noise</code>","text":"<p>The Noise class provides a simple implementation of a noise value generator using a random walk approach. It generates a sequence of noise values that vary within a specified range, with each new value computed relative to the previous one. The variation is controlled by the noise_range parameter, which represents a fraction of the total range between the minimum and maximum values.</p>"},{"location":"reference/noise/noise/#dreampletnoisenoise","title":"<code>dreamplet.noise.Noise</code>","text":"<pre><code>Noise(min_val: float, max_val: float, noise_range: float)\n</code></pre> <p>Parameters</p> <ul> <li><code>min_val</code> (float): The lower bound for the noise value.</li> <li><code>max_val</code> (float): The upper bound for the noise value.</li> <li><code>noise_range</code> (float): The fraction (between 0 and 1) of the total range used for generating random walk steps.</li> </ul> <pre><code>noise_gen = Noise(0.0, 100.0, 0.1)\nprint(noise_gen.value)  # Outputs a new noise value within the specified bounds\n</code></pre>"},{"location":"reference/noise/noise/#min","title":"<code>min</code>","text":"<p>Getter: Returns the current minimum bound.</p> <pre><code>current_min = noise_gen.min\n</code></pre> <p>Setter: Updates the minimum bound. If the current noise value is below the new minimum, it is adjusted to the new minimum. The effective noise range is recalculated accordingly.</p> <pre><code>noise_gen.min = 10.0\n</code></pre>"},{"location":"reference/noise/noise/#max","title":"<code>max</code>","text":"<p>Getter: Returns the current maximum bound.</p> <pre><code>current_max = noise_gen.max\n</code></pre> <p>Setter: Updates the maximum bound. If the current noise value exceeds the new maximum, it is adjusted to the new maximum. The effective noise range is recalculated accordingly.</p> <pre><code>noise_gen.max = 90.0\n</code></pre>"},{"location":"reference/noise/noise/#noise_range","title":"<code>noise_range</code>","text":"<p>Getter: Returns the current noise range as a fraction of the total range (max - min). If the total range is zero, it returns 0.</p> <pre><code>current_noise_range = noise_gen.noise_range\n</code></pre> <p>Setter: Sets the noise range as a fraction (between 0 and 1) of the total range (max - min). Internally, it computes the absolute range used for generating the next value.</p> <pre><code>noise_gen.noise_range = 0.2\n</code></pre>"},{"location":"reference/noise/noise/#value","title":"<code>value</code>","text":"<p>Getter: Returns the next noise value computed using a random walk algorithm. Each access generates a new value that varies randomly within a window defined by the current noise range and then updates the internal state.</p> <pre><code>current_value = noise_gen.value\n</code></pre> <p>Setter: Directly sets the noise value if the provided value lies within the [min, max] bounds.</p> <pre><code>noise_gen.value = 50.0\n</code></pre>"},{"location":"reference/noise/noise/#int_value","title":"<code>int_value</code>","text":"<p>Getter: Returns the next noise value as an integer, by rounding the computed float value. Like value, accessing this property updates the internal noise state.</p> <pre><code>rounded_value = noise_gen.int_value\n</code></pre>"},{"location":"reference/noise/noise/#_next_value","title":"<code>_next_value</code>","text":"<p>This internal method computes the next noise value. It defines a window centered around the current value with a width equal to the absolute noise range. If the computed window exceeds the [min, max] bounds, it adjusts the window to remain within limits before generating the new value using a uniform random distribution.</p> <p>Note: This method is used internally and is automatically invoked when accessing the value or int_value properties.</p>"},{"location":"reference/noise/simplex/","title":"<code>SimplexNoise</code>","text":"<p>The SimplexNoise class is a one-dimensional noise generator that builds on the functionality provided by the NoiseBase class. It implements the simplex noise algorithm to produce smooth noise values that are roughly in the range [-1, 1] when the amplitude is set to 1. These values are then mapped to the [0, 1] range and scaled by the provided amplitude.</p>"},{"location":"reference/noise/simplex/#dreampletnoisesimplexnoise","title":"<code>dreamplet.noise.SimplexNoise</code>","text":"<pre><code>SimplexNoise(seed: int = None)\n</code></pre> <p>Parameters</p> <ul> <li><code>seed</code> (int, optional): An optional seed for noise generation. Providing a seed ensures that the noise sequence is reproducible.</li> </ul> <pre><code>from pydreamplet.noise import SimplexNoise\n\nsimplex = SimplexNoise(seed=42)\nprint(simplex.noise(0.5))\n</code></pre>"},{"location":"reference/noise/simplex/#noise","title":"<code>noise</code>","text":"<pre><code>noise(self, x: float, frequency: float = 1, amplitude: float = 1) -&gt; float\n</code></pre> <p>Generates a noise value for a given coordinate using the simplex noise algorithm.</p> <p>Parameters</p> <ul> <li><code>x</code> (floaf): The input coordinate at which to compute the noise.</li> <li><code>frequency</code> (float, optional): Scales the input coordinate. Default value is 1.</li> <li><code>amplitude</code> (float, optional): Scales the resulting noise value. Default value is 1.</li> </ul> <p>Returns</p> <ul> <li>(floaf): The noise value computed at the given coordinate, mapped from the raw range of approximately [-1, 1] to [0, 1] and then scaled by the amplitude.</li> </ul> <p>How it works</p> <ol> <li>Input Scaling: The input coordinate x is multiplied by frequency to control the noise detail.</li> <li>Lattice Points: The function determines the integer coordinates surrounding x (i.e., i0 and i1) and calculates the distances (x0 and x1).</li> <li>Weight Calculation: Two weights (t0 and t1) are computed using a quadratic attenuation function.</li> <li>Gradient Contributions: For each lattice point, if the corresponding weight is positive, it is squared and used to calculate a contribution via the internal _grad method.</li> <li>Noise Aggregation: The contributions are combined into a raw noise value, which is roughly in the range [-1, 1].</li> <li>Mapping and Scaling: The raw noise value is mapped to the [0, 1] range and then scaled by the provided amplitude.</li> </ol>"},{"location":"reference/noise/simplex2D/","title":"<code>SimplexNoise2D</code>","text":"<p>The SimplexNoise2D class is a two-dimensional noise generator based on the simplex noise algorithm. It produces smooth, continuous noise values that are roughly in the range [-1, 1] when the amplitude is 1. These values are then mapped to the [0, 1] interval and scaled by the provided amplitude. This class is useful for generating terrain, textures, or other procedural content in two dimensions.</p>"},{"location":"reference/noise/simplex2D/#dreampletnoisesimplexnoise2d","title":"<code>dreamplet.noise.SimplexNoise2D</code>","text":"<pre><code>SimplexNoise2D(seed: int = None)\n</code></pre> <p>Parameters</p> <ul> <li><code>seed</code> (int, optional): An optional seed for noise generation. When provided, the noise sequence will be reproducible.</li> </ul> <pre><code>from pydreamplet.noise import SimplexNoise2D\n\nsimplex2d = SimplexNoise2D(seed=123)\nvalue = simplex2d.noise(10.5, 20.75, frequency=0.05, amplitude=1.0)\nprint(value)  # Outputs a noise value scaled to [0, 1]\n</code></pre>"},{"location":"reference/noise/simplex2D/#noise","title":"<code>noise</code>","text":"<pre><code>noise(\n    self,\n    x: float,\n    y: float,\n    frequency: float = 1,\n    amplitude: float = 1,\n) -&gt; float\n</code></pre> <p>Generates a noise value for the specified 2D coordinates.</p> <p>Parameters</p> <ul> <li><code>x</code> (float): The x-coordinate input.</li> <li><code>y</code> (float): The y-coordinate input.</li> <li><code>frequency</code> (float, optional): Scales the input coordinates to control the level of detail. Default is 1.</li> <li><code>amplitude</code> (float, optional): Scales the resulting noise value. Default is 1.</li> </ul> <p>Returns</p> <ul> <li>(float): The noise value, mapped from a raw value in approximately [-1, 1] to a [0, 1] range, and then scaled by the amplitude.</li> </ul> <p>How it works</p> <ol> <li>Input Scaling: The coordinates (xin, yin) are multiplied by the frequency.</li> <li>Skewing and Unskewing: The algorithm applies a skewing factor (using F2) to transform the input space into simplex space, then computes the unskewed distances.</li> <li>Corner Contributions: It determines the simplex triangle for the input point and calculates contributions from each corner using an attenuation function.</li> <li>Noise Aggregation: The contributions from the three corners are summed, scaled, and remapped from [-1, 1] to [0, 1] by the amplitude.</li> </ol> <pre><code>noise_value = simplex2d.noise(5.0, 15.0, frequency=0.1, amplitude=0.8)\n</code></pre>"},{"location":"reference/noise/simplex3D/","title":"<code>SimplexNoise3D</code>","text":"<p>The SimplexNoise3D class extends the simplex noise algorithm into three dimensions. It generates smooth noise values that are roughly in the range [-1, 1] when the amplitude is 1. These values are then mapped to the [0, 1] interval and scaled by the amplitude. This 3D noise is useful for volumetric effects, 3D procedural textures, or other applications requiring noise in three-dimensional space.</p>"},{"location":"reference/noise/simplex3D/#dreampletnoisesimplexnoise3d","title":"<code>dreamplet.noise.SimplexNoise3D</code>","text":"<pre><code>SimplexNoise3D(seed: int = None)\n</code></pre> <p>Parameters</p> <ul> <li><code>seed</code> (int, optional): An optional seed for noise generation. When provided, the noise sequence will be reproducible.</li> </ul> <pre><code>from pydreamplet.noise import SimplexNoise3D\n\nsimplex3d = SimplexNoise3D(seed=456)\nvalue = simplex3d.noise(2.0, 3.5, 7.8, frequency=0.2, amplitude=1.0)\nprint(value)  # Outputs a noise value scaled to [0, 1]\n</code></pre>"},{"location":"reference/noise/simplex3D/#noise","title":"<code>noise</code>","text":"<pre><code>noise(\n    self,\n    x: float, \n    y: float,\n    z: float,\n    frequency: float = 1,\n    amplitude: float = 1\n) -&gt; float\n</code></pre> <p>Generates a noise value for the specified 3D coordinates.</p> <p>Parameters</p> <ul> <li><code>x</code> (float): The x-coordinate input.</li> <li><code>y</code> (float): The y-coordinate input.</li> <li><code>z</code> (float): The z-coordinate input.</li> <li><code>frequency</code> (float, optional): Scales the input coordinates to control the level of detail. Default is 1.</li> <li><code>amplitude</code> (float, optional): Scales the resulting noise value. Default is 1.</li> </ul> <p>Returns</p> <ul> <li>(float): The noise value, remapped from an approximate raw range of [-1, 1] to [0, 1] and then scaled by the amplitude.</li> </ul> <p>How it works</p> <ol> <li>Input Scaling: The (x, y, z) coordinates are scaled by the frequency.</li> <li>Skewing the Input Space: The coordinates are skewed using a factor (derived from F3) to determine the simplex cell.</li> <li>Simplex Cell Determination: The algorithm identifies the simplex cell (a tetrahedron in 3D) that contains the input point.</li> <li>Corner Contributions: It calculates contributions from the four corners of the tetrahedron, applying an attenuation function based on the distance from the input point.</li> <li>Noise Aggregation: The contributions are summed, scaled by a factor (32.0), and remapped from the raw noise range to the final [0, 1] range after applying the amplitude.</li> </ol>"},{"location":"reference/scales/","title":"Scales","text":"<p>Scales are functions that map from an input domain to an output range. They are useful for data visualization, allowing you to convert data values to visual properties like position, size, or color.</p>"},{"location":"reference/scales/#type-definitions","title":"Type Definitions","text":""},{"location":"reference/scales/#real","title":"<code>Real</code>","text":"<p>A type alias defined in <code>pydreamplet.core</code> representing numeric values:</p> <pre><code>type Real = int | float\n</code></pre> <p>This type is used throughout the library for parameters that accept both integers and floating-point numbers.</p>"},{"location":"reference/scales/#numericpair","title":"<code>NumericPair</code>","text":"<p>A type alias defined in <code>pydreamplet.scales</code> for representing numeric ranges:</p> <pre><code>type NumericPair = tuple[Real, Real] | list[Real]\n</code></pre> <p>This type represents a pair of numeric values used for domains and ranges in scale functions. It can be either a tuple or a list containing two <code>Real</code> values.</p>"},{"location":"reference/scales/#scale-classes","title":"Scale Classes","text":"<ul> <li><code>LinearScale</code> - Linear mapping between numeric domains</li> <li><code>BandScale</code> - Maps categories to evenly spaced bands</li> <li><code>PointScale</code> - Maps categories to discrete points</li> <li><code>OrdinalScale</code> - Maps categories to output values in cyclic fashion</li> <li><code>ColorScale</code> - Interpolates between colors based on numeric input</li> <li><code>SquareScale</code> - Square-root transformation for area-based scaling</li> <li><code>CircleScale</code> - Maps values to circle radii with area proportionality</li> </ul>"},{"location":"reference/scales/bandscale/","title":"<code>BandScale</code>","text":"<p>The <code>BandScale</code> class maps categorical values (strings) to evenly spaced positions within the output range. It allows configuration of inner padding and outer padding.</p>"},{"location":"reference/scales/bandscale/#pydreampletscalesbandscale","title":"<code>pydreamplet.scales.BandScale</code>","text":"<pre><code>BandScale(\n    domain: list[Any],\n    output_range: NumericPair,\n    padding: float = 0.1,\n    outer_padding: float | None = None\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (list[Any]): A list of categorical values (distinct).</li> <li><code>output_range</code> (NumericPair): The numeric output range.</li> <li><code>padding</code> (float, optional): The inner padding between bands (default: 0.1).</li> <li><code>outer_padding</code> (float, optional): The outer padding; defaults to the inner padding if not provided.</li> </ul> <pre><code>from pydreamplet.scales import BandScale\n\nband = BandScale([\"A\", \"B\", \"C\"], (0, 300))\nprint(band.map(\"B\"))  # Outputs the start position for category \"B\"\nprint(band.bandwidth)  # Width of each band\n</code></pre>"},{"location":"reference/scales/bandscale/#map","title":"<code>map</code>","text":"<pre><code>map(value: Any) -&gt; float\n</code></pre> <p>Returns the starting position of the band for the given categorical value.</p>"},{"location":"reference/scales/bandscale/#bandwidth","title":"<code>bandwidth</code>","text":"<p>Returns the computed width of each band.</p>"},{"location":"reference/scales/bandscale/#domain","title":"<code>domain</code>","text":"<p>Get or set the list of categories.</p>"},{"location":"reference/scales/bandscale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the numeric output range.</p>"},{"location":"reference/scales/bandscale/#padding","title":"<code>padding</code>","text":"<p>Get or set the inner padding.</p>"},{"location":"reference/scales/bandscale/#outer_padding","title":"<code>outer_padding</code>","text":"<p>Get or set the outer padding.</p>"},{"location":"reference/scales/circlescale/","title":"<code>CircleScale</code>","text":"<p>The <code>CircleScale</code> class maps an input value to a circle radius such that the circle\u2019s area is linearly proportional to the input value. This ensures that if the area of a circle is meant to represent a value, the radius is calculated appropriately.</p>"},{"location":"reference/scales/circlescale/#pydreampletscalescirclescale","title":"<code>pydreamplet.scales.CircleScale</code>","text":"<pre><code>CircleScale(\n    domain: NumericPair,\n    output_range: NumericPair\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (NumericPair): The numeric input domain.</li> <li><code>output_range</code> (NumericPair): The desired radius range (rmin, rmax).</li> </ul> <pre><code>from pydreamplet.scales import CircleScale\n\ncircle_scale = CircleScale((0, 100), (5, 20))\nprint(circle_scale.map(50))  # Outputs the radius corresponding to the value 50\n</code></pre>"},{"location":"reference/scales/circlescale/#map","title":"<code>map</code>","text":"<pre><code>map(value: float) -&gt; float\n</code></pre> <p>Maps the input value to a circle radius based on area proportionality.</p>"},{"location":"reference/scales/circlescale/#domain","title":"<code>domain</code>","text":"<p>Get or set the numeric domain.</p>"},{"location":"reference/scales/circlescale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the radius range.</p>"},{"location":"reference/scales/colorscale/","title":"<code>ColorScale</code>","text":"<p>The <code>ColorScale</code> class creates a color scale that maps a numeric value from a given domain to an interpolated hex color between two specified colors.</p>"},{"location":"reference/scales/colorscale/#pydreampletscalescolorscale","title":"<code>pydreamplet.scales.ColorScale</code>","text":"<pre><code>ColorScale(\n    domain: NumericPair,\n    output_range: tuple[str, str]\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (NumericPair): The numeric input domain.</li> <li><code>output_range</code> (tuple[str, str]): A tuple of two hex color strings representing the start and end colors.</li> </ul> <pre><code>from pydreamplet.scales import ColorScale\n\ncolor_scale = ColorScale((0, 100), (\"#ff0000\", \"#00ff00\"))\nprint(color_scale.map(50))  # Outputs an #7f7f00\n</code></pre>"},{"location":"reference/scales/colorscale/#map","title":"<code>map</code>","text":"<pre><code>map(value: float) -&gt; str\n</code></pre> <p>Maps the input numeric value to an interpolated hex color.</p>"},{"location":"reference/scales/colorscale/#domain","title":"<code>domain</code>","text":"<p>Get or set the numeric domain.</p>"},{"location":"reference/scales/colorscale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the pair of hex colors.</p>"},{"location":"reference/scales/linearscale/","title":"<code>LinearScale</code>","text":"<p>The <code>LinearScale</code> class maps a numeric value from a specified domain to an output range using a linear transformation.</p>"},{"location":"reference/scales/linearscale/#pydreampletscaleslinearscale","title":"<code>pydreamplet.scales.LinearScale</code>","text":"<pre><code>LinearScale(\n    domain: NumericPair,\n    output_range: NumericPair\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (NumericPair): The input domain as a minimum and maximum value.</li> <li><code>output_range</code> (NumericPair): The target output range.</li> </ul> <pre><code>from pydreamplet.scales import LinearScale\n\nscale = LinearScale((0, 100), (0, 1))\nprint(scale.map(50))  # Output: 0.5\nprint(scale.invert(0.75))  # Output: 75.0\n</code></pre>"},{"location":"reference/scales/linearscale/#map","title":"<code>map</code>","text":"<pre><code>map(value: float) -&gt; float\n</code></pre> <p>Scales a value from the domain to the output range.</p>"},{"location":"reference/scales/linearscale/#invert","title":"<code>invert</code>","text":"<pre><code>invert(value: float) -&gt; float\n</code></pre> <p>Maps a value from the output range back to the domain.</p>"},{"location":"reference/scales/linearscale/#domain","title":"<code>domain</code>","text":"<p>Get or set the input domain.</p>"},{"location":"reference/scales/linearscale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the target output range.</p>"},{"location":"reference/scales/ordinalscale/","title":"<code>OrdinalScale</code>","text":"<p>The <code>OrdinalScale</code> class maps categorical values to a set of output values in a cyclic (repeating) fashion. This is useful for assigning properties like colors in order.</p>"},{"location":"reference/scales/ordinalscale/#pydreampletscalesordinalscale","title":"<code>pydreamplet.scales.OrdinalScale</code>","text":"<pre><code>OrdinalScale(domain: list[Any], output_range: list)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (list[Any]): A list of categorical values (distinct).</li> <li><code>output_range</code> (list): A list of output values (e.g., colors) to map to, which are reused cyclically.</li> </ul> <pre><code>from pydreamplet.scales import OrdinalScale\n\nordinal = OrdinalScale([\"apple\", \"banana\", \"cherry\"], [\"red\", \"yellow\"])\nprint(ordinal.map(\"cherry\"))  # Output: \"red\" (wraps around)\n</code></pre>"},{"location":"reference/scales/ordinalscale/#map","title":"<code>map</code>","text":"<pre><code>map(value: Any) -&gt; object\n</code></pre> <p>Returns the mapped output value for the given domain value.</p>"},{"location":"reference/scales/ordinalscale/#domain","title":"<code>domain</code>","text":"<p>Get or set the list of categories.</p>"},{"location":"reference/scales/ordinalscale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the list of output values.</p>"},{"location":"reference/scales/pointscale/","title":"<code>PointScale</code>","text":"<p>The <code>PointScale</code> class maps categorical values to discrete points within the output range, with specified padding at both ends.</p>"},{"location":"reference/scales/pointscale/#pydreampletscalespointscale","title":"<code>pydreamplet.scales.PointScale</code>","text":"<pre><code>PointScale(\n    domain: list[Any],\n    output_range: NumericPair,\n    padding: float = 0.5\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (list[Any]): A list of categorical values (distinct).</li> <li><code>output_range</code> (NumericPair): The numeric output range.</li> <li><code>padding</code> (float, optional): The amount of padding on each end (default: 0.5).</li> </ul> <pre><code>from pydreamplet.scales import PointScale\n\npoint = PointScale([\"X\", \"Y\", \"Z\"], (0, 100))\nprint(point.map(\"Y\"))  # Outputs the point corresponding to \"Y\"\n</code></pre>"},{"location":"reference/scales/pointscale/#map","title":"<code>map</code>","text":"<pre><code>map(value: Any) -&gt; float | None\n</code></pre> <p>Maps a categorical value to a discrete point; returns None if the value is not in the domain.</p>"},{"location":"reference/scales/pointscale/#domain","title":"<code>domain</code>","text":"<p>Get or set the list of categories.</p>"},{"location":"reference/scales/pointscale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the numeric output range.</p>"},{"location":"reference/scales/pointscale/#padding","title":"<code>padding</code>","text":"<p>Get or set the padding value.</p>"},{"location":"reference/scales/squarescale/","title":"<code>SquareScale</code>","text":"<p>The <code>SquareScale</code> class maps an input value to an output using a square-root transformation. This is useful when a visual property (e.g., a square's side length) should be proportional to the square root of the area.</p>"},{"location":"reference/scales/squarescale/#pydreampletscalessquarescale","title":"<code>pydreamplet.scales.SquareScale</code>","text":"<pre><code>SquareScale(\n    domain: NumericPair,\n    output_range: NumericPair\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>domain</code> (NumericPair): The input domain (non-negative values).</li> <li><code>output_range</code> (NumericPair): The target output range.</li> </ul> <pre><code>from pydreamplet.scales import SquareScale\n\nsquare = SquareScale((0, 100), (0, 10))\nprint(square.map(25))  # Maps the square-root of 25 to the output range\n</code></pre>"},{"location":"reference/scales/squarescale/#map","title":"<code>map</code>","text":"<pre><code>map(value: float) -&gt; float\n</code></pre> <p>Scales the value using a square-root transformation.</p>"},{"location":"reference/scales/squarescale/#domain","title":"<code>domain</code>","text":"<p>Get or set the numeric domain.</p>"},{"location":"reference/scales/squarescale/#output_range","title":"<code>output_range</code>","text":"<p>Get or set the target output range.</p>"},{"location":"reference/shapes/","title":"<code>d</code>-string generators","text":"<p>This module provides functions to generate SVG path <code>d</code>-strings for various geometric shapes. These functions return strings suitable for use in the \"d\" attribute of SVG path elements.</p>"},{"location":"reference/shapes/#star","title":"<code>star</code>","text":"<pre><code>star(\n    x: float = 0,\n    y: float = 0,\n    n: int = 5,\n    *, \n    inner_radius: float,\n    outer_radius: float,\n    angle: float = 0\n) -&gt; str\n</code></pre> <p>Returns a <code>d</code>-string for a star with <code>n</code> points. The star is centered at <code>(x, y)</code> and is constructed using alternating outer and inner vertices.</p> <p>Parameters</p> <ul> <li><code>x</code> (float, optional): x-coordinate of the center (default: 0).</li> <li><code>y</code> (float, optional): y-coordinate of the center (default: 0).</li> <li><code>n</code> (int, optional): Number of star points (default: 5).</li> <li><code>inner_radius</code> (float): Radius for the inner vertices.</li> <li><code>outer_radius</code> (float): Radius for the outer vertices.</li> <li><code>angle</code> (float, optional): Rotation angle in degrees for the first outer vertex (default: 0).</li> </ul> <p>Returns</p> <ul> <li>(str): A string suitable for the \"d\" attribute in an SVG path element.</li> </ul> <pre><code>from pydreamplet.shapes import star\n\nd_str = star(inner_radius=10, outer_radius=20)\nprint(d_str)\n</code></pre>"},{"location":"reference/shapes/#polyline","title":"<code>polyline</code>","text":"<pre><code>polyline(\n    x_coords: Sequence[float],\n    y_coords: Sequence[float]\n) -&gt; str\n</code></pre> <p>Returns a <code>d</code>-string for a polyline connecting points specified by <code>x_coords</code> and <code>y_coords</code>. Raises a <code>ValueError</code> if the lengths of <code>x_coords</code> and <code>y_coords</code> do not match.</p> <p>Parameters</p> <ul> <li><code>x_coords</code> (Sequence[float]): A sequence of x coordinates.</li> <li><code>y_coords</code> (Sequence[float]): A sequence of y coordinates.</li> </ul> <p>Returns</p> <p>(str): A string suitable for the \"d\" attribute in an SVG path element.</p> <pre><code>from pydreamplet.shapes import polyline\n\nd_str = polyline([0, 50, 100], [0, 100, 0])\nprint(d_str)\n</code></pre>"},{"location":"reference/shapes/#cardinal_spline","title":"<code>cardinal_spline</code>","text":"<pre><code>cardinal_spline(\n    points: list[Real] | list[tuple[Real, Real]],\n    tension: float = 0.0,\n    closed: bool = False,\n) -&gt; str\n</code></pre> <p>Generates an SVG path <code>d</code> string for a cardinal spline that smoothly interpolates through a set of points with adjustable tension. The spline is built from a series of cubic B\u00e9zier segments computed using the cardinal spline algorithm. A <code>tension</code> of <code>0.0</code> produces the classic smooth cardinal spline, while a <code>tension</code> of <code>1.0</code> yields straight-line segments. When <code>closed</code> is <code>True</code>, the spline wraps around so that the last point connects back to the first.</p> <p>Parameters</p> <ul> <li><code>points</code> (list[Real] | list[tuple[Real, Real]]): A sequence of points. This can be a flat list in the form <code>[x0, y0, x1, y1, \u2026]</code> or a list of <code>(x, y)</code> tuples.</li> <li><code>tension</code> (float): A number between <code>0.0</code> and <code>1.0</code> that controls the curvature of the spline. Lower values yield a looser, more curved line; higher values produce a tighter, straighter line.</li> <li><code>closed</code> (bool): Whether the spline should be closed (i.e. the last point connects back to the first).</li> </ul> <p>Returns</p> <p>(str): A string suitable for the <code>d</code> attribute of an SVG <code>&lt;path&gt;</code> element.</p> <pre><code>from pydreamplet.shapes import cardinal_spline\n\nd_str = cardinal_spline(\n    [50, 50, 100, 100, 150, 50, 200, 100, 250, 50, 300, 100, 350, 50],\n    tension=0.5,\n    closed=False\n)\nprint(d_str)\n</code></pre>"},{"location":"reference/shapes/#polygon","title":"<code>polygon</code>","text":"<pre><code>polygon(\n    x: float,\n    y: float,\n    radius: float,\n    n: int,\n    angle: float = 0,\n) -&gt; str\n</code></pre> <p>Returns a <code>d</code>-string for a regular polygon with <code>n</code> sides. The polygon is centered at <code>(x, y)</code> and is inscribed in a circle of the specified <code>radius</code>. An optional rotation <code>angle</code> (in degrees) is applied, rotating the polygon around its center. By default, the first vertex is positioned at the top of the circle (i.e. at -90\u00b0) and then rotated by the given <code>angle</code>.</p> <p>Parameters</p> <ul> <li><code>x</code> (float): The x-coordinate of the polygon\u2019s center.</li> <li><code>y</code> (float): The y-coordinate of the polygon\u2019s center.</li> <li><code>radius</code> (float): The radius of the circle in which the polygon is inscribed.</li> <li><code>n</code> (int): The number of sides (vertices) of the polygon.</li> <li><code>angle</code> (float): The rotation angle in degrees to be applied to the polygon (default is 0).</li> </ul> <p>Returns</p> <p>(str): A string suitable for the d attribute of an SVG <code>&lt;path&gt;</code> element.</p> <pre><code>from pydreamplet.shapes import polygon\n\nd_str = polygon(200, 200, 100, 6)\nprint(d_str)\n</code></pre>"},{"location":"reference/shapes/#cross","title":"<code>cross</code>","text":"<pre><code>cross(\n    x: float = 0,\n    y: float = 0,\n    *,\n    size: float,\n    thickness: float,\n    angle: float = 0\n) -&gt; str\n</code></pre> <p>Returns a <code>d</code>-string for a cross centered at <code>(x, y)</code> with a given <code>size</code>, <code>thickness</code>, and rotation <code>angle</code>. The cross is formed by combining a vertical rectangle and a horizontal rectangle into a polygon with 12 vertices.</p> <p>Parameters</p> <ul> <li><code>x</code> (float, optional): x-coordinate of the center (default: 0).</li> <li><code>y</code> (float, optional): y-coordinate of the center (default: 0).</li> <li><code>size</code> (float): Total span (tip-to-tip) of the cross.</li> <li><code>thickness</code> (float): Thickness of the cross arms.</li> <li><code>angle</code> (float, optional): Rotation angle in degrees (default: 0).</li> </ul> <p>Returns</p> <p>(str): A string suitable for the \"d\" attribute in an SVG path element.</p> <pre><code>from pydreamplet.shapes import cross\n\nd_str = cross(size=50, thickness=10, angle=45)\nprint(d_str)\n</code></pre>"},{"location":"reference/shapes/#arc","title":"<code>arc</code>","text":"<pre><code>arc(\n    x: float = 0,\n    y: float = 0,\n    *,\n    radius: float,\n    start_angle: float = 0,\n    end_angle: float = 360\n) -&gt; str\n</code></pre> <p>Returns a <code>d</code>-string for an arc (a circular path) centered at <code>(x, y)</code> with the specified <code>radius</code>. The arc spans from <code>start_angle</code> to <code>end_angle</code> (in degrees). If the arc represents a full circle, it is drawn using two 180\u00b0 arc segments.</p> <p>Parameters</p> <ul> <li><code>x</code> (float, optional): x-coordinate of the center (default: 0).</li> <li><code>y</code> (float, optional): y-coordinate of the center (default: 0).</li> <li><code>radius</code> (float): Radius of the arc.</li> <li><code>start_angle</code> (float, optional): Starting angle in degrees (default: 0).</li> <li>end_angle (float, optional): Ending angle in degrees (default: 360).</li> </ul> <p>Returns</p> <p>(str): A string suitable for the \"d\" attribute in an SVG path element.</p> <pre><code>from pydreamplet.shapes import arc\n\nd_str = arc(radius=30, start_angle=0, end_angle=180)\nprint(d_str)\n</code></pre>"},{"location":"reference/shapes/#ring","title":"<code>ring</code>","text":"<pre><code>ring(\n    x: float = 0,\n    y: float = 0,\n    *,\n    inner_radius: float,\n    outer_radius: float,\n    start_angle: float = 0,\n    end_angle: float = 360,\n    without_inner: bool = False\n) -&gt; str\n</code></pre> <p>Returns a <code>d</code>-string for a ring (donut or ring segment) centered at <code>(x, y)</code> with specified <code>inner_radius</code> and <code>outer_radius</code>.</p> <p>For a full ring (360\u00b0), a complete donut is drawn. For a partial ring: If <code>without_inner</code> is <code>False</code>, a full ring segment is drawn (outer arc, radial line to inner arc, inner arc, and radial line back). If <code>without_inner</code> is <code>True</code>, the inner arc is omitted and a single closed path is drawn.</p> <p>Parameters</p> <ul> <li><code>x</code> (float, optional): x-coordinate of the center (default: 0).</li> <li><code>y</code> (float, optional): y-coordinate of the center (default: 0).</li> <li><code>inner_radius</code> (float): Inner radius of the ring.</li> <li><code>outer_radius</code> (float): Outer radius of the ring.</li> <li><code>start_angle</code> (float, optional): Starting angle in degrees (default: 0).</li> <li><code>end_angle</code> (float, optional): Ending angle in degrees (default: 360).</li> <li><code>without_inner</code> (bool, optional): If True, omits the inner arc for partial rings (default: False).</li> </ul> <p>Returns</p> <p>(str): A string suitable for the \"d\" attribute in an SVG path element.</p> <pre><code>from pydreamplet.shapes import ring\n\nd_str = ring(inner_radius=20, outer_radius=40, start_angle=45, end_angle=315)\nprint(d_str)\n</code></pre>"},{"location":"reference/typography/","title":"Font utilities","text":"<p>This module provides functions and classes for working with system fonts and measuring text dimensions. It includes a utility function to search for a system font file that matches a given font family and weight, as well as a class to measure the width and height of rendered text using the PIL library.</p>"},{"location":"reference/typography/#get_system_font_path","title":"<code>get_system_font_path</code>","text":"<pre><code>get_system_font_path(\n    font_family: str,\n    weight: int = 400,\n    weight_tolerance: int = 100\n) -&gt; str | None\n</code></pre> <p>Searches common system directories for a TrueType or OpenType font file (<code>.ttf</code> or <code>.otf</code>) that matches the specified <code>font_family</code> and is within the desired weight tolerance.</p> <p>Parameters</p> <ul> <li><code>font_family</code> (str): The desired system font name (e.g., \"Arial\").</li> <li><code>weight</code> (int, optional): The numeric weight (e.g., 400 for regular, 700 for bold; default: 400).</li> <li><code>weight_tolerance</code> (int, optional): Allowed difference between the desired weight and the font's actual weight (default: 100).</li> </ul> <p>Returns</p> <p>(str | None): The full path to the matching font file, or None if no match is found.</p> <pre><code>from pydreamplet.typography import get_system_font_path\n\npath = get_system_font_path(\"Arial\", 400)\nif path:\n    print(\"Found font:\", path)\nelse:\n    print(\"Font not found\")\n</code></pre>"},{"location":"reference/typography/#typographymeasurer","title":"<code>TypographyMeasurer</code>","text":"<p>The TypographyMeasurer class measures the rendered width and height of text given a specific font and size. It converts point sizes to pixels based on the provided DPI and leverages the PIL library for text measurement.</p> <pre><code>TypographyMeasurer(dpi: float = 72.0, font_path: str | None = None)\n</code></pre> <p>Parameters</p> <ul> <li><code>dpi</code> (float, optional): Dots per inch for converting point sizes to pixels (default: 72.0).</li> <li><code>font_path</code> (str | None, optional): The path to a font file. If not provided, the system is searched using get_system_font_path.</li> </ul> <pre><code>measurer = TypographyMeasurer(dpi=96)\n</code></pre>"},{"location":"reference/typography/#measure_text","title":"<code>measure_text</code>","text":"<pre><code>measure_text(\n    text: str,\n    font_family: str | None = None,\n    weight: int | None = None,\n    font_size: Real = 12.0\n) -&gt; tuple[float, float]\n</code></pre> <p>Measures the width and height (in pixels) of the provided text when rendered in the specified font. Multiline text is supported if newline characters are present.</p> <p>Parameters</p> <ul> <li><code>text</code> (str): The text to measure.</li> <li><code>font_family</code> (str | None, optional): The system font name (e.g., \"Arial\"). Required if no font_path is already set.</li> <li><code>weight</code> (int | None, optional): Numeric weight (e.g., 400 for regular, 700 for bold). Required if no font_path is already set.</li> <li><code>font_size</code> (Real, optional): The desired font size in points (default: 12.0).</li> </ul> <p>Returns</p> <p>(tuple[float, float]): A tuple (width, height) in pixels.</p> <p>raises <code>ValueError</code>: If the specified font cannot be found (when both <code>font_path</code> is not provided and <code>font_family</code> or <code>weight</code> are missing).</p> <pre><code>measurer = TypographyMeasurer()\nwidth, height = measurer.measure_text(\n    \"Hello\\nWorld\",\n    font_family=\"Arial\",\n    weight=400,\n    font_size=14,\n)\nprint(f\"Text dimensions: {width}px x {height}px\")\n</code></pre>"},{"location":"reference/utils/","title":"Helper functions","text":"<p>This module provides utility functions for various mathematical operations and unit conversions. It includes functions for rounding numbers using a round half up method, constraining values within a specified range, converting between degrees and radians, and generating rounded tick values for grid lines.</p>"},{"location":"reference/utils/#math_round","title":"<code>math_round</code>","text":"<pre><code>math_round(x)\n</code></pre> <p>Rounds <code>x</code> to the nearest integer using the round half up method.</p> <p>Parameters</p> <ul> <li><code>x</code> (float): The number to round.</li> </ul> <p>Returns</p> <p>(int): The rounded integer.</p> <pre><code>from pydreamplet.utils import math_round\n\nprint(math_round(3.4))  # Output: 3\nprint(math_round(3.6))  # Output: 4\n</code></pre>"},{"location":"reference/utils/#constrain","title":"<code>constrain</code>","text":"<pre><code>constrain(value, min_val, max_val)\n</code></pre> <p>Constrains the given <code>value</code> between <code>min_val</code> and <code>max_val</code>.</p> <p>Parameters</p> <ul> <li><code>value</code> (numeric): The value to be constrained.</li> <li><code>min_val</code> (numeric): The minimum allowed value.</li> <li><code>max_val</code> (numeric): The maximum allowed value.</li> </ul> <p>Returns</p> <p>(numeric): The constrained value.</p> <pre><code>from pydreamplet.utils import constrain\n\nprint(constrain(10, 0, 5))  # Output: 5\nprint(constrain(-3, 0, 5))  # Output: 0\n</code></pre>"},{"location":"reference/utils/#radians","title":"<code>radians</code>","text":"<pre><code>radians(degrees)\n</code></pre> <p>Converts an angle from degrees to radians.</p> <p>Parameters</p> <ul> <li><code>degrees</code> (float): Angle in degrees.</li> </ul> <p>Returns</p> <p>(float): Angle in radians.</p> <pre><code>from pydreamplet.utils import radians\n\nprint(radians(180))  # Output: 3.141592653589793 (approximately)\n</code></pre>"},{"location":"reference/utils/#degrees","title":"<code>degrees</code>","text":"<pre><code>degrees(radians)\n</code></pre> <p>Converts an angle from radians to degrees.</p> <p>Parameters</p> <ul> <li><code>radians</code> (float): Angle in radians.</li> </ul> <p>Returns</p> <p>(float): Angle in degrees.</p> <pre><code>from pydreamplet.utils import degrees\n\nprint(degrees(3.141592653589793))  # Output: 180.0\n</code></pre>"},{"location":"reference/utils/#calculate_ticks","title":"<code>calculate_ticks</code>","text":"<pre><code>calculate_ticks(min_val, max_val, num_ticks=5, below_max=True)\n</code></pre> <p>Generates a list of rounded tick values between <code>min_val</code> and <code>max_val</code>. The number of ticks is approximately equal to <code>num_ticks</code>.</p> <p>Parameters</p> <ul> <li><code>min_val</code> (Real): The minimum value.</li> <li><code>max_val</code> (Real): The maximum value.</li> <li><code>num_ticks</code> (int, optional): The desired number of tick values (default: 5).</li> <li><code>below_max</code> (bool): If set to <code>True</code> last tick is always below <code>max_val</code>. Default: <code>True</code></li> </ul> <p>Returns</p> <p>(list[Real]): A list of rounded tick values.</p> <p>Raises <code>ValueError</code>: If min_val is not less than max_val.</p> <pre><code>from pydreamplet.utils import calculate_ticks\n\n# Integer range\nticks = calculate_ticks(0, 100, num_ticks=5)\nprint(ticks)  # Output: [0, 20, 40, 60, 80, 100]\n\n# Decimal range (0 to 1)\nticks = calculate_ticks(0, 1, num_ticks=5)\nprint(ticks)  # Output: [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]\n\n# Small decimal range\nticks = calculate_ticks(0.1, 0.9, num_ticks=4)\nprint(ticks)  # Output: [0.2, 0.4, 0.6, 0.8]\n</code></pre>"},{"location":"reference/utils/#pie_angles","title":"<code>pie_angles</code>","text":"<pre><code>pie_angles(values, start_angle=0, end_angle=360)\n</code></pre> <p>Calculates the start and end angles (in degrees) for each pie slice based on their proportional values. The function divides the specified angle span among the slices in proportion to their values.</p> <p>Parameters</p> <ul> <li><code>values</code> (list[Real]): A list of numerical values representing the sizes of each pie slice.</li> <li><code>start_angle</code> (Real, optional): The starting angle (in degrees) for the first slice (default: 0).</li> <li><code>end_angle</code> (Real, optional): The ending angle (in degrees) for the last slice (default: 360).</li> </ul> <p>Returns</p> <p>(list[tuple[Real, Real]]): A list of tuples where each tuple contains the start and end angles for a slice.</p> <p>Raises <code>ZeroDivisionError</code>: If the sum of <code>values</code> is zero.</p> <pre><code>from pydreamplet.utils import pie_angles\n\nangles = pie_angles([1, 2, 3])\nprint(angles)  \n# [(0, 60.0), (60.0, 180.0), (180.0, 360.0)]\n\n# Creating a semicircle pie chart\nsemi_angles = pie_angles([1, 2, 3], end_angle=180)\nprint(semi_angles)\n# [(0, 30.0), (30.0, 90.0), (90.0, 180.0)]\n</code></pre> Usage example<pre><code>import pydreamplet as dp\nfrom pydreamplet.shapes import ring\nfrom pydreamplet.utils import pie_angles\nfrom pydreamplet.colors import generate_colors\n\ndata = [25, 34, 18, 72]\n\nsvg = dp.SVG(400, 400)\ng = dp.G(pos=dp.Vector(svg.w / 2, svg.h / 2))\nsvg.append(g)\n\nsegments = pie_angles(sorted(data, reverse=True), -90)\ncolors = generate_colors(\"#db45f9\", len(segments))\n\nfor i, segment in enumerate(segments):\n    g.append(dp.Path(\n        d=ring(0, 0, inner_radius=50, outer_radius=150, start_angle=segment[0], end_angle=segment[1]),\n        fill=colors[i]\n    ))\n\nsvg.display()\n</code></pre> <p></p>"},{"location":"reference/utils/#sample_uniform","title":"<code>sample_uniform</code>","text":"<pre><code>sample_uniform(my_list, n, precedence=\"first\")\n</code></pre> <p>Selects uniformly spaced indices from a list based on the total number of items, the desired number of selections, and an optional anchoring (precedence) parameter. The function returns a tuple of indices chosen from the list such that they are as evenly distributed as possible.</p> <p>Parameters</p> <ul> <li><code>input_list</code> (list[Any]): A list containing elements of any type.</li> <li><code>n</code> (int): The number of indices to select from the list.</li> <li><code>precedence</code> (str | None, optional): Determines which end of the list is anchored during sampling. Use <code>\"first\"</code> (default) to always include the first element, <code>\"last\"</code> to always include the last element, or <code>None</code> for an unanchored, balanced selection.</li> </ul> <p>Returns</p> <p>(tuple[int]): A tuple of indices representing the uniformly spaced positions within the list.</p> <p>Raises <code>ValueError</code>: If precedence is not <code>\"first\"</code>, <code>\"last\"</code>, or <code>None</code>.</p> <pre><code>from pydreamplet.utils import sample_uniform\n\n# With \"first\" precedence (anchoring the first element):\nindices = sample_uniform([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"], n=4, precedence=\"first\")\nprint(indices)  # Expected output: (0, 3, 6, 9)\n\n# With \"last\" precedence (anchoring the last element):\nindices = sample_uniform([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"], n=3, precedence=\"last\")\nprint(indices)  # Expected output: (1, 5, 9)\n\n# With no precedence (balanced selection):\nindices = sample_uniform([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"], n=4, precedence=None)\nprint(indices)  # Expected output: (1, 3, 7, 10)\n</code></pre>"},{"location":"reference/utils/#force_distance","title":"<code>force_distance</code>","text":"<pre><code>force_distance(values, distance)\n</code></pre> <p>Adjusts an unsorted list of numeric label positions so that the spacing between adjacent labels is at least the specified distance. The function ensures that each adjusted label remains within \u00b1distance/2 of its original value while keeping the new positions as close as possible to the input values. Internally, the input list is sorted for processing, and the computed positions are then re-mapped to match the original order.</p> <p>Parameters</p> <ul> <li><code>values</code> (list[float]): A sorted list of original numeric label positions.</li> <li><code>distance</code> (float): The minimum required distance between adjacent labels. Each label can shift within the interval <code>[v - distance/2, v + distance/2]</code> relative to its original position.</li> </ul> <p>Returns</p> <p>(list[float]): A list of adjusted label positions that meet the minimum spacing requirement, returned in the same order as the input list.</p> <pre><code>from pydreamplet.utils import force_distance\n\ninput_values = [2, 6, 7, 8, 10, 16, 18]\nadjusted_positions = force_distance(input_values, distance=2)\nprint(adjusted_positions)  # Expected output: [2, 5, 7, 9, 11, 16, 18]\n</code></pre> <p>Internally, the function reformulates each position as <code>x[i] = y[i] + i * distance</code>, which reduces the spacing constraint to requiring that the sequence <code>y</code> is non-decreasing. A pooling algorithm is then applied to adjust the values while ensuring each remains within its allowed interval.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/data-visualization/","title":"Data Visualization","text":""}]}